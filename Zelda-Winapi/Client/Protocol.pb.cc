// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: Protocol.proto

#include "Protocol.pb.h"

#include <algorithm>

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/wire_format_lite.h>
#include <google/protobuf/descriptor.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/reflection_ops.h>
#include <google/protobuf/wire_format.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>

PROTOBUF_PRAGMA_INIT_SEG

namespace _pb = ::PROTOBUF_NAMESPACE_ID;
namespace _pbi = _pb::internal;

namespace Protocol {
PROTOBUF_CONSTEXPR S_TEST::S_TEST(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.buffs_)*/{}
  , /*decltype(_impl_.id_)*/uint64_t{0u}
  , /*decltype(_impl_.hp_)*/0u
  , /*decltype(_impl_.attack_)*/0u
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct S_TESTDefaultTypeInternal {
  PROTOBUF_CONSTEXPR S_TESTDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~S_TESTDefaultTypeInternal() {}
  union {
    S_TEST _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 S_TESTDefaultTypeInternal _S_TEST_default_instance_;
PROTOBUF_CONSTEXPR S_EnterGame::S_EnterGame(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.accountid_)*/uint64_t{0u}
  , /*decltype(_impl_.success_)*/false
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct S_EnterGameDefaultTypeInternal {
  PROTOBUF_CONSTEXPR S_EnterGameDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~S_EnterGameDefaultTypeInternal() {}
  union {
    S_EnterGame _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 S_EnterGameDefaultTypeInternal _S_EnterGame_default_instance_;
PROTOBUF_CONSTEXPR S_MyPlayer::S_MyPlayer(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.info_)*/nullptr
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct S_MyPlayerDefaultTypeInternal {
  PROTOBUF_CONSTEXPR S_MyPlayerDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~S_MyPlayerDefaultTypeInternal() {}
  union {
    S_MyPlayer _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 S_MyPlayerDefaultTypeInternal _S_MyPlayer_default_instance_;
PROTOBUF_CONSTEXPR S_AddObject::S_AddObject(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.objects_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct S_AddObjectDefaultTypeInternal {
  PROTOBUF_CONSTEXPR S_AddObjectDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~S_AddObjectDefaultTypeInternal() {}
  union {
    S_AddObject _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 S_AddObjectDefaultTypeInternal _S_AddObject_default_instance_;
PROTOBUF_CONSTEXPR S_RemoveObject::S_RemoveObject(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.ids_)*/{}
  , /*decltype(_impl_._ids_cached_byte_size_)*/{0}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct S_RemoveObjectDefaultTypeInternal {
  PROTOBUF_CONSTEXPR S_RemoveObjectDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~S_RemoveObjectDefaultTypeInternal() {}
  union {
    S_RemoveObject _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 S_RemoveObjectDefaultTypeInternal _S_RemoveObject_default_instance_;
PROTOBUF_CONSTEXPR C_Move::C_Move(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.dir_)*/0
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct C_MoveDefaultTypeInternal {
  PROTOBUF_CONSTEXPR C_MoveDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~C_MoveDefaultTypeInternal() {}
  union {
    C_Move _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 C_MoveDefaultTypeInternal _C_Move_default_instance_;
PROTOBUF_CONSTEXPR S_Move::S_Move(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.info_)*/nullptr
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct S_MoveDefaultTypeInternal {
  PROTOBUF_CONSTEXPR S_MoveDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~S_MoveDefaultTypeInternal() {}
  union {
    S_Move _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 S_MoveDefaultTypeInternal _S_Move_default_instance_;
PROTOBUF_CONSTEXPR C_Turn::C_Turn(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.dir_)*/0
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct C_TurnDefaultTypeInternal {
  PROTOBUF_CONSTEXPR C_TurnDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~C_TurnDefaultTypeInternal() {}
  union {
    C_Turn _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 C_TurnDefaultTypeInternal _C_Turn_default_instance_;
PROTOBUF_CONSTEXPR S_Turn::S_Turn(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.info_)*/nullptr
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct S_TurnDefaultTypeInternal {
  PROTOBUF_CONSTEXPR S_TurnDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~S_TurnDefaultTypeInternal() {}
  union {
    S_Turn _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 S_TurnDefaultTypeInternal _S_Turn_default_instance_;
PROTOBUF_CONSTEXPR C_Attack::C_Attack(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.dir_)*/0
  , /*decltype(_impl_.weapontype_)*/0
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct C_AttackDefaultTypeInternal {
  PROTOBUF_CONSTEXPR C_AttackDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~C_AttackDefaultTypeInternal() {}
  union {
    C_Attack _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 C_AttackDefaultTypeInternal _C_Attack_default_instance_;
PROTOBUF_CONSTEXPR S_Attack::S_Attack(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.attackerid_)*/uint64_t{0u}
  , /*decltype(_impl_.dir_)*/0
  , /*decltype(_impl_.weapontype_)*/0
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct S_AttackDefaultTypeInternal {
  PROTOBUF_CONSTEXPR S_AttackDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~S_AttackDefaultTypeInternal() {}
  union {
    S_Attack _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 S_AttackDefaultTypeInternal _S_Attack_default_instance_;
PROTOBUF_CONSTEXPR S_Damaged::S_Damaged(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.attackerid_)*/uint64_t{0u}
  , /*decltype(_impl_.targetid_)*/uint64_t{0u}
  , /*decltype(_impl_.newhp_)*/0
  , /*decltype(_impl_.damage_)*/0
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct S_DamagedDefaultTypeInternal {
  PROTOBUF_CONSTEXPR S_DamagedDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~S_DamagedDefaultTypeInternal() {}
  union {
    S_Damaged _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 S_DamagedDefaultTypeInternal _S_Damaged_default_instance_;
PROTOBUF_CONSTEXPR C_ChangeMap::C_ChangeMap(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.mapid_)*/0
  , /*decltype(_impl_.channel_)*/0
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct C_ChangeMapDefaultTypeInternal {
  PROTOBUF_CONSTEXPR C_ChangeMapDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~C_ChangeMapDefaultTypeInternal() {}
  union {
    C_ChangeMap _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 C_ChangeMapDefaultTypeInternal _C_ChangeMap_default_instance_;
PROTOBUF_CONSTEXPR S_ChangeMap::S_ChangeMap(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.success_)*/false
  , /*decltype(_impl_.mapid_)*/0
  , /*decltype(_impl_.instanceid_)*/uint64_t{0u}
  , /*decltype(_impl_.channel_)*/0
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct S_ChangeMapDefaultTypeInternal {
  PROTOBUF_CONSTEXPR S_ChangeMapDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~S_ChangeMapDefaultTypeInternal() {}
  union {
    S_ChangeMap _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 S_ChangeMapDefaultTypeInternal _S_ChangeMap_default_instance_;
PROTOBUF_CONSTEXPR S_GainExp::S_GainExp(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.playerid_)*/uint64_t{0u}
  , /*decltype(_impl_.gainedexp_)*/0
  , /*decltype(_impl_.currentexp_)*/0
  , /*decltype(_impl_.maxexp_)*/0
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct S_GainExpDefaultTypeInternal {
  PROTOBUF_CONSTEXPR S_GainExpDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~S_GainExpDefaultTypeInternal() {}
  union {
    S_GainExp _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 S_GainExpDefaultTypeInternal _S_GainExp_default_instance_;
PROTOBUF_CONSTEXPR S_LevelUp::S_LevelUp(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.playerid_)*/uint64_t{0u}
  , /*decltype(_impl_.newlevel_)*/0
  , /*decltype(_impl_.maxhp_)*/0
  , /*decltype(_impl_.attack_)*/0
  , /*decltype(_impl_.defence_)*/0
  , /*decltype(_impl_.maxexp_)*/0
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct S_LevelUpDefaultTypeInternal {
  PROTOBUF_CONSTEXPR S_LevelUpDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~S_LevelUpDefaultTypeInternal() {}
  union {
    S_LevelUp _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 S_LevelUpDefaultTypeInternal _S_LevelUp_default_instance_;
PROTOBUF_CONSTEXPR S_InventoryData::S_InventoryData(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.items_)*/{}
  , /*decltype(_impl_.equippedweapon_)*/nullptr
  , /*decltype(_impl_.equippedarmor_)*/nullptr
  , /*decltype(_impl_.equippedpotion_)*/nullptr
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct S_InventoryDataDefaultTypeInternal {
  PROTOBUF_CONSTEXPR S_InventoryDataDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~S_InventoryDataDefaultTypeInternal() {}
  union {
    S_InventoryData _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 S_InventoryDataDefaultTypeInternal _S_InventoryData_default_instance_;
PROTOBUF_CONSTEXPR S_AddItem::S_AddItem(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.itemid_)*/0
  , /*decltype(_impl_.slot_)*/0
  , /*decltype(_impl_.count_)*/0
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct S_AddItemDefaultTypeInternal {
  PROTOBUF_CONSTEXPR S_AddItemDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~S_AddItemDefaultTypeInternal() {}
  union {
    S_AddItem _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 S_AddItemDefaultTypeInternal _S_AddItem_default_instance_;
PROTOBUF_CONSTEXPR S_EquipItem::S_EquipItem(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.equiptype_)*/0
  , /*decltype(_impl_.storageslot_)*/0
  , /*decltype(_impl_.storageitemid_)*/0
  , /*decltype(_impl_.storageitemcount_)*/0
  , /*decltype(_impl_.equipitemid_)*/0
  , /*decltype(_impl_.equipitemcount_)*/0
  , /*decltype(_impl_.attack_)*/0
  , /*decltype(_impl_.defence_)*/0
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct S_EquipItemDefaultTypeInternal {
  PROTOBUF_CONSTEXPR S_EquipItemDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~S_EquipItemDefaultTypeInternal() {}
  union {
    S_EquipItem _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 S_EquipItemDefaultTypeInternal _S_EquipItem_default_instance_;
PROTOBUF_CONSTEXPR S_UnequipItem::S_UnequipItem(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.equiptype_)*/0
  , /*decltype(_impl_.storageslot_)*/0
  , /*decltype(_impl_.attack_)*/0
  , /*decltype(_impl_.defence_)*/0
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct S_UnequipItemDefaultTypeInternal {
  PROTOBUF_CONSTEXPR S_UnequipItemDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~S_UnequipItemDefaultTypeInternal() {}
  union {
    S_UnequipItem _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 S_UnequipItemDefaultTypeInternal _S_UnequipItem_default_instance_;
PROTOBUF_CONSTEXPR S_UseItem::S_UseItem(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.equiptype_)*/0
  , /*decltype(_impl_.remaincount_)*/0
  , /*decltype(_impl_.newhp_)*/0
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct S_UseItemDefaultTypeInternal {
  PROTOBUF_CONSTEXPR S_UseItemDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~S_UseItemDefaultTypeInternal() {}
  union {
    S_UseItem _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 S_UseItemDefaultTypeInternal _S_UseItem_default_instance_;
PROTOBUF_CONSTEXPR C_EquipItem::C_EquipItem(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.slot_)*/0
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct C_EquipItemDefaultTypeInternal {
  PROTOBUF_CONSTEXPR C_EquipItemDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~C_EquipItemDefaultTypeInternal() {}
  union {
    C_EquipItem _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 C_EquipItemDefaultTypeInternal _C_EquipItem_default_instance_;
PROTOBUF_CONSTEXPR C_UnequipItem::C_UnequipItem(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.equiptype_)*/0
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct C_UnequipItemDefaultTypeInternal {
  PROTOBUF_CONSTEXPR C_UnequipItemDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~C_UnequipItemDefaultTypeInternal() {}
  union {
    C_UnequipItem _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 C_UnequipItemDefaultTypeInternal _C_UnequipItem_default_instance_;
PROTOBUF_CONSTEXPR C_UseItem::C_UseItem(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.slot_)*/0
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct C_UseItemDefaultTypeInternal {
  PROTOBUF_CONSTEXPR C_UseItemDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~C_UseItemDefaultTypeInternal() {}
  union {
    C_UseItem _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 C_UseItemDefaultTypeInternal _C_UseItem_default_instance_;
}  // namespace Protocol
static ::_pb::Metadata file_level_metadata_Protocol_2eproto[24];
static constexpr ::_pb::EnumDescriptor const** file_level_enum_descriptors_Protocol_2eproto = nullptr;
static constexpr ::_pb::ServiceDescriptor const** file_level_service_descriptors_Protocol_2eproto = nullptr;

const uint32_t TableStruct_Protocol_2eproto::offsets[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::Protocol::S_TEST, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::Protocol::S_TEST, _impl_.id_),
  PROTOBUF_FIELD_OFFSET(::Protocol::S_TEST, _impl_.hp_),
  PROTOBUF_FIELD_OFFSET(::Protocol::S_TEST, _impl_.attack_),
  PROTOBUF_FIELD_OFFSET(::Protocol::S_TEST, _impl_.buffs_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::Protocol::S_EnterGame, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::Protocol::S_EnterGame, _impl_.success_),
  PROTOBUF_FIELD_OFFSET(::Protocol::S_EnterGame, _impl_.accountid_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::Protocol::S_MyPlayer, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::Protocol::S_MyPlayer, _impl_.info_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::Protocol::S_AddObject, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::Protocol::S_AddObject, _impl_.objects_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::Protocol::S_RemoveObject, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::Protocol::S_RemoveObject, _impl_.ids_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::Protocol::C_Move, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::Protocol::C_Move, _impl_.dir_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::Protocol::S_Move, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::Protocol::S_Move, _impl_.info_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::Protocol::C_Turn, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::Protocol::C_Turn, _impl_.dir_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::Protocol::S_Turn, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::Protocol::S_Turn, _impl_.info_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::Protocol::C_Attack, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::Protocol::C_Attack, _impl_.dir_),
  PROTOBUF_FIELD_OFFSET(::Protocol::C_Attack, _impl_.weapontype_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::Protocol::S_Attack, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::Protocol::S_Attack, _impl_.attackerid_),
  PROTOBUF_FIELD_OFFSET(::Protocol::S_Attack, _impl_.dir_),
  PROTOBUF_FIELD_OFFSET(::Protocol::S_Attack, _impl_.weapontype_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::Protocol::S_Damaged, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::Protocol::S_Damaged, _impl_.attackerid_),
  PROTOBUF_FIELD_OFFSET(::Protocol::S_Damaged, _impl_.targetid_),
  PROTOBUF_FIELD_OFFSET(::Protocol::S_Damaged, _impl_.newhp_),
  PROTOBUF_FIELD_OFFSET(::Protocol::S_Damaged, _impl_.damage_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::Protocol::C_ChangeMap, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::Protocol::C_ChangeMap, _impl_.mapid_),
  PROTOBUF_FIELD_OFFSET(::Protocol::C_ChangeMap, _impl_.channel_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::Protocol::S_ChangeMap, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::Protocol::S_ChangeMap, _impl_.success_),
  PROTOBUF_FIELD_OFFSET(::Protocol::S_ChangeMap, _impl_.mapid_),
  PROTOBUF_FIELD_OFFSET(::Protocol::S_ChangeMap, _impl_.channel_),
  PROTOBUF_FIELD_OFFSET(::Protocol::S_ChangeMap, _impl_.instanceid_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::Protocol::S_GainExp, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::Protocol::S_GainExp, _impl_.playerid_),
  PROTOBUF_FIELD_OFFSET(::Protocol::S_GainExp, _impl_.gainedexp_),
  PROTOBUF_FIELD_OFFSET(::Protocol::S_GainExp, _impl_.currentexp_),
  PROTOBUF_FIELD_OFFSET(::Protocol::S_GainExp, _impl_.maxexp_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::Protocol::S_LevelUp, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::Protocol::S_LevelUp, _impl_.playerid_),
  PROTOBUF_FIELD_OFFSET(::Protocol::S_LevelUp, _impl_.newlevel_),
  PROTOBUF_FIELD_OFFSET(::Protocol::S_LevelUp, _impl_.maxhp_),
  PROTOBUF_FIELD_OFFSET(::Protocol::S_LevelUp, _impl_.attack_),
  PROTOBUF_FIELD_OFFSET(::Protocol::S_LevelUp, _impl_.defence_),
  PROTOBUF_FIELD_OFFSET(::Protocol::S_LevelUp, _impl_.maxexp_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::Protocol::S_InventoryData, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::Protocol::S_InventoryData, _impl_.items_),
  PROTOBUF_FIELD_OFFSET(::Protocol::S_InventoryData, _impl_.equippedweapon_),
  PROTOBUF_FIELD_OFFSET(::Protocol::S_InventoryData, _impl_.equippedarmor_),
  PROTOBUF_FIELD_OFFSET(::Protocol::S_InventoryData, _impl_.equippedpotion_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::Protocol::S_AddItem, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::Protocol::S_AddItem, _impl_.itemid_),
  PROTOBUF_FIELD_OFFSET(::Protocol::S_AddItem, _impl_.slot_),
  PROTOBUF_FIELD_OFFSET(::Protocol::S_AddItem, _impl_.count_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::Protocol::S_EquipItem, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::Protocol::S_EquipItem, _impl_.equiptype_),
  PROTOBUF_FIELD_OFFSET(::Protocol::S_EquipItem, _impl_.storageslot_),
  PROTOBUF_FIELD_OFFSET(::Protocol::S_EquipItem, _impl_.storageitemid_),
  PROTOBUF_FIELD_OFFSET(::Protocol::S_EquipItem, _impl_.storageitemcount_),
  PROTOBUF_FIELD_OFFSET(::Protocol::S_EquipItem, _impl_.equipitemid_),
  PROTOBUF_FIELD_OFFSET(::Protocol::S_EquipItem, _impl_.equipitemcount_),
  PROTOBUF_FIELD_OFFSET(::Protocol::S_EquipItem, _impl_.attack_),
  PROTOBUF_FIELD_OFFSET(::Protocol::S_EquipItem, _impl_.defence_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::Protocol::S_UnequipItem, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::Protocol::S_UnequipItem, _impl_.equiptype_),
  PROTOBUF_FIELD_OFFSET(::Protocol::S_UnequipItem, _impl_.storageslot_),
  PROTOBUF_FIELD_OFFSET(::Protocol::S_UnequipItem, _impl_.attack_),
  PROTOBUF_FIELD_OFFSET(::Protocol::S_UnequipItem, _impl_.defence_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::Protocol::S_UseItem, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::Protocol::S_UseItem, _impl_.equiptype_),
  PROTOBUF_FIELD_OFFSET(::Protocol::S_UseItem, _impl_.remaincount_),
  PROTOBUF_FIELD_OFFSET(::Protocol::S_UseItem, _impl_.newhp_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::Protocol::C_EquipItem, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::Protocol::C_EquipItem, _impl_.slot_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::Protocol::C_UnequipItem, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::Protocol::C_UnequipItem, _impl_.equiptype_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::Protocol::C_UseItem, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::Protocol::C_UseItem, _impl_.slot_),
};
static const ::_pbi::MigrationSchema schemas[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  { 0, -1, -1, sizeof(::Protocol::S_TEST)},
  { 10, -1, -1, sizeof(::Protocol::S_EnterGame)},
  { 18, -1, -1, sizeof(::Protocol::S_MyPlayer)},
  { 25, -1, -1, sizeof(::Protocol::S_AddObject)},
  { 32, -1, -1, sizeof(::Protocol::S_RemoveObject)},
  { 39, -1, -1, sizeof(::Protocol::C_Move)},
  { 46, -1, -1, sizeof(::Protocol::S_Move)},
  { 53, -1, -1, sizeof(::Protocol::C_Turn)},
  { 60, -1, -1, sizeof(::Protocol::S_Turn)},
  { 67, -1, -1, sizeof(::Protocol::C_Attack)},
  { 75, -1, -1, sizeof(::Protocol::S_Attack)},
  { 84, -1, -1, sizeof(::Protocol::S_Damaged)},
  { 94, -1, -1, sizeof(::Protocol::C_ChangeMap)},
  { 102, -1, -1, sizeof(::Protocol::S_ChangeMap)},
  { 112, -1, -1, sizeof(::Protocol::S_GainExp)},
  { 122, -1, -1, sizeof(::Protocol::S_LevelUp)},
  { 134, -1, -1, sizeof(::Protocol::S_InventoryData)},
  { 144, -1, -1, sizeof(::Protocol::S_AddItem)},
  { 153, -1, -1, sizeof(::Protocol::S_EquipItem)},
  { 167, -1, -1, sizeof(::Protocol::S_UnequipItem)},
  { 177, -1, -1, sizeof(::Protocol::S_UseItem)},
  { 186, -1, -1, sizeof(::Protocol::C_EquipItem)},
  { 193, -1, -1, sizeof(::Protocol::C_UnequipItem)},
  { 200, -1, -1, sizeof(::Protocol::C_UseItem)},
};

static const ::_pb::Message* const file_default_instances[] = {
  &::Protocol::_S_TEST_default_instance_._instance,
  &::Protocol::_S_EnterGame_default_instance_._instance,
  &::Protocol::_S_MyPlayer_default_instance_._instance,
  &::Protocol::_S_AddObject_default_instance_._instance,
  &::Protocol::_S_RemoveObject_default_instance_._instance,
  &::Protocol::_C_Move_default_instance_._instance,
  &::Protocol::_S_Move_default_instance_._instance,
  &::Protocol::_C_Turn_default_instance_._instance,
  &::Protocol::_S_Turn_default_instance_._instance,
  &::Protocol::_C_Attack_default_instance_._instance,
  &::Protocol::_S_Attack_default_instance_._instance,
  &::Protocol::_S_Damaged_default_instance_._instance,
  &::Protocol::_C_ChangeMap_default_instance_._instance,
  &::Protocol::_S_ChangeMap_default_instance_._instance,
  &::Protocol::_S_GainExp_default_instance_._instance,
  &::Protocol::_S_LevelUp_default_instance_._instance,
  &::Protocol::_S_InventoryData_default_instance_._instance,
  &::Protocol::_S_AddItem_default_instance_._instance,
  &::Protocol::_S_EquipItem_default_instance_._instance,
  &::Protocol::_S_UnequipItem_default_instance_._instance,
  &::Protocol::_S_UseItem_default_instance_._instance,
  &::Protocol::_C_EquipItem_default_instance_._instance,
  &::Protocol::_C_UnequipItem_default_instance_._instance,
  &::Protocol::_C_UseItem_default_instance_._instance,
};

const char descriptor_table_protodef_Protocol_2eproto[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) =
  "\n\016Protocol.proto\022\010Protocol\032\nEnum.proto\032\014"
  "Struct.proto\"S\n\006S_TEST\022\n\n\002id\030\001 \001(\004\022\n\n\002hp"
  "\030\002 \001(\r\022\016\n\006attack\030\003 \001(\r\022!\n\005buffs\030\004 \003(\0132\022."
  "Protocol.BuffData\"1\n\013S_EnterGame\022\017\n\007succ"
  "ess\030\001 \001(\010\022\021\n\taccountId\030\002 \001(\004\"0\n\nS_MyPlay"
  "er\022\"\n\004info\030\001 \001(\0132\024.Protocol.ObjectInfo\"4"
  "\n\013S_AddObject\022%\n\007objects\030\001 \003(\0132\024.Protoco"
  "l.ObjectInfo\"\035\n\016S_RemoveObject\022\013\n\003ids\030\001 "
  "\003(\004\")\n\006C_Move\022\037\n\003dir\030\001 \001(\0162\022.Protocol.DI"
  "R_TYPE\",\n\006S_Move\022\"\n\004info\030\001 \001(\0132\024.Protoco"
  "l.ObjectInfo\")\n\006C_Turn\022\037\n\003dir\030\001 \001(\0162\022.Pr"
  "otocol.DIR_TYPE\",\n\006S_Turn\022\"\n\004info\030\001 \001(\0132"
  "\024.Protocol.ObjectInfo\"V\n\010C_Attack\022\037\n\003dir"
  "\030\001 \001(\0162\022.Protocol.DIR_TYPE\022)\n\nweaponType"
  "\030\002 \001(\0162\025.Protocol.WEAPON_TYPE\"j\n\010S_Attac"
  "k\022\022\n\nattackerId\030\001 \001(\004\022\037\n\003dir\030\002 \001(\0162\022.Pro"
  "tocol.DIR_TYPE\022)\n\nweaponType\030\003 \001(\0162\025.Pro"
  "tocol.WEAPON_TYPE\"P\n\tS_Damaged\022\022\n\nattack"
  "erId\030\001 \001(\004\022\020\n\010targetId\030\002 \001(\004\022\r\n\005newHp\030\003 "
  "\001(\005\022\016\n\006damage\030\004 \001(\005\"\?\n\013C_ChangeMap\022\037\n\005ma"
  "pId\030\001 \001(\0162\020.Protocol.MAP_ID\022\017\n\007channel\030\002"
  " \001(\005\"d\n\013S_ChangeMap\022\017\n\007success\030\001 \001(\010\022\037\n\005"
  "mapId\030\002 \001(\0162\020.Protocol.MAP_ID\022\017\n\007channel"
  "\030\003 \001(\005\022\022\n\ninstanceId\030\004 \001(\004\"T\n\tS_GainExp\022"
  "\020\n\010playerId\030\001 \001(\004\022\021\n\tgainedExp\030\002 \001(\005\022\022\n\n"
  "currentExp\030\003 \001(\005\022\016\n\006maxExp\030\004 \001(\005\"o\n\tS_Le"
  "velUp\022\020\n\010playerId\030\001 \001(\004\022\020\n\010newLevel\030\002 \001("
  "\005\022\r\n\005maxHp\030\003 \001(\005\022\016\n\006attack\030\004 \001(\005\022\017\n\007defe"
  "nce\030\005 \001(\005\022\016\n\006maxExp\030\006 \001(\005\"\267\001\n\017S_Inventor"
  "yData\022!\n\005items\030\001 \003(\0132\022.Protocol.ItemInfo"
  "\022*\n\016equippedWeapon\030\002 \001(\0132\022.Protocol.Item"
  "Info\022)\n\requippedArmor\030\003 \001(\0132\022.Protocol.I"
  "temInfo\022*\n\016equippedPotion\030\004 \001(\0132\022.Protoc"
  "ol.ItemInfo\"8\n\tS_AddItem\022\016\n\006itemId\030\001 \001(\005"
  "\022\014\n\004slot\030\002 \001(\005\022\r\n\005count\030\003 \001(\005\"\264\001\n\013S_Equi"
  "pItem\022\021\n\tequipType\030\001 \001(\005\022\023\n\013storageSlot\030"
  "\002 \001(\005\022\025\n\rstorageItemId\030\003 \001(\005\022\030\n\020storageI"
  "temCount\030\004 \001(\005\022\023\n\013equipItemId\030\005 \001(\005\022\026\n\016e"
  "quipItemCount\030\006 \001(\005\022\016\n\006attack\030\007 \001(\005\022\017\n\007d"
  "efence\030\010 \001(\005\"X\n\rS_UnequipItem\022\021\n\tequipTy"
  "pe\030\001 \001(\005\022\023\n\013storageSlot\030\002 \001(\005\022\016\n\006attack\030"
  "\003 \001(\005\022\017\n\007defence\030\004 \001(\005\"B\n\tS_UseItem\022\021\n\te"
  "quipType\030\001 \001(\005\022\023\n\013remainCount\030\002 \001(\005\022\r\n\005n"
  "ewHp\030\003 \001(\005\"\033\n\013C_EquipItem\022\014\n\004slot\030\001 \001(\005\""
  "\"\n\rC_UnequipItem\022\021\n\tequipType\030\001 \001(\005\"\031\n\tC"
  "_UseItem\022\014\n\004slot\030\001 \001(\005b\006proto3"
  ;
static const ::_pbi::DescriptorTable* const descriptor_table_Protocol_2eproto_deps[2] = {
  &::descriptor_table_Enum_2eproto,
  &::descriptor_table_Struct_2eproto,
};
static ::_pbi::once_flag descriptor_table_Protocol_2eproto_once;
const ::_pbi::DescriptorTable descriptor_table_Protocol_2eproto = {
    false, false, 1830, descriptor_table_protodef_Protocol_2eproto,
    "Protocol.proto",
    &descriptor_table_Protocol_2eproto_once, descriptor_table_Protocol_2eproto_deps, 2, 24,
    schemas, file_default_instances, TableStruct_Protocol_2eproto::offsets,
    file_level_metadata_Protocol_2eproto, file_level_enum_descriptors_Protocol_2eproto,
    file_level_service_descriptors_Protocol_2eproto,
};
PROTOBUF_ATTRIBUTE_WEAK const ::_pbi::DescriptorTable* descriptor_table_Protocol_2eproto_getter() {
  return &descriptor_table_Protocol_2eproto;
}

// Force running AddDescriptors() at dynamic initialization time.
PROTOBUF_ATTRIBUTE_INIT_PRIORITY2 static ::_pbi::AddDescriptorsRunner dynamic_init_dummy_Protocol_2eproto(&descriptor_table_Protocol_2eproto);
namespace Protocol {

// ===================================================================

class S_TEST::_Internal {
 public:
};

void S_TEST::clear_buffs() {
  _impl_.buffs_.Clear();
}
S_TEST::S_TEST(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:Protocol.S_TEST)
}
S_TEST::S_TEST(const S_TEST& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  S_TEST* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.buffs_){from._impl_.buffs_}
    , decltype(_impl_.id_){}
    , decltype(_impl_.hp_){}
    , decltype(_impl_.attack_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.id_, &from._impl_.id_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.attack_) -
    reinterpret_cast<char*>(&_impl_.id_)) + sizeof(_impl_.attack_));
  // @@protoc_insertion_point(copy_constructor:Protocol.S_TEST)
}

inline void S_TEST::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.buffs_){arena}
    , decltype(_impl_.id_){uint64_t{0u}}
    , decltype(_impl_.hp_){0u}
    , decltype(_impl_.attack_){0u}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

S_TEST::~S_TEST() {
  // @@protoc_insertion_point(destructor:Protocol.S_TEST)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void S_TEST::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.buffs_.~RepeatedPtrField();
}

void S_TEST::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void S_TEST::Clear() {
// @@protoc_insertion_point(message_clear_start:Protocol.S_TEST)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.buffs_.Clear();
  ::memset(&_impl_.id_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.attack_) -
      reinterpret_cast<char*>(&_impl_.id_)) + sizeof(_impl_.attack_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* S_TEST::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // uint64 id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _impl_.id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint32 hp = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _impl_.hp_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint32 attack = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _impl_.attack_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .Protocol.BuffData buffs = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_buffs(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<34>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* S_TEST::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:Protocol.S_TEST)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // uint64 id = 1;
  if (this->_internal_id() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(1, this->_internal_id(), target);
  }

  // uint32 hp = 2;
  if (this->_internal_hp() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(2, this->_internal_hp(), target);
  }

  // uint32 attack = 3;
  if (this->_internal_attack() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(3, this->_internal_attack(), target);
  }

  // repeated .Protocol.BuffData buffs = 4;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_buffs_size()); i < n; i++) {
    const auto& repfield = this->_internal_buffs(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(4, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:Protocol.S_TEST)
  return target;
}

size_t S_TEST::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:Protocol.S_TEST)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .Protocol.BuffData buffs = 4;
  total_size += 1UL * this->_internal_buffs_size();
  for (const auto& msg : this->_impl_.buffs_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // uint64 id = 1;
  if (this->_internal_id() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_id());
  }

  // uint32 hp = 2;
  if (this->_internal_hp() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_hp());
  }

  // uint32 attack = 3;
  if (this->_internal_attack() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_attack());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData S_TEST::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    S_TEST::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*S_TEST::GetClassData() const { return &_class_data_; }


void S_TEST::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<S_TEST*>(&to_msg);
  auto& from = static_cast<const S_TEST&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:Protocol.S_TEST)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.buffs_.MergeFrom(from._impl_.buffs_);
  if (from._internal_id() != 0) {
    _this->_internal_set_id(from._internal_id());
  }
  if (from._internal_hp() != 0) {
    _this->_internal_set_hp(from._internal_hp());
  }
  if (from._internal_attack() != 0) {
    _this->_internal_set_attack(from._internal_attack());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void S_TEST::CopyFrom(const S_TEST& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:Protocol.S_TEST)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool S_TEST::IsInitialized() const {
  return true;
}

void S_TEST::InternalSwap(S_TEST* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.buffs_.InternalSwap(&other->_impl_.buffs_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(S_TEST, _impl_.attack_)
      + sizeof(S_TEST::_impl_.attack_)
      - PROTOBUF_FIELD_OFFSET(S_TEST, _impl_.id_)>(
          reinterpret_cast<char*>(&_impl_.id_),
          reinterpret_cast<char*>(&other->_impl_.id_));
}

::PROTOBUF_NAMESPACE_ID::Metadata S_TEST::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_Protocol_2eproto_getter, &descriptor_table_Protocol_2eproto_once,
      file_level_metadata_Protocol_2eproto[0]);
}

// ===================================================================

class S_EnterGame::_Internal {
 public:
};

S_EnterGame::S_EnterGame(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:Protocol.S_EnterGame)
}
S_EnterGame::S_EnterGame(const S_EnterGame& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  S_EnterGame* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.accountid_){}
    , decltype(_impl_.success_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.accountid_, &from._impl_.accountid_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.success_) -
    reinterpret_cast<char*>(&_impl_.accountid_)) + sizeof(_impl_.success_));
  // @@protoc_insertion_point(copy_constructor:Protocol.S_EnterGame)
}

inline void S_EnterGame::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.accountid_){uint64_t{0u}}
    , decltype(_impl_.success_){false}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

S_EnterGame::~S_EnterGame() {
  // @@protoc_insertion_point(destructor:Protocol.S_EnterGame)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void S_EnterGame::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void S_EnterGame::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void S_EnterGame::Clear() {
// @@protoc_insertion_point(message_clear_start:Protocol.S_EnterGame)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::memset(&_impl_.accountid_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.success_) -
      reinterpret_cast<char*>(&_impl_.accountid_)) + sizeof(_impl_.success_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* S_EnterGame::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // bool success = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _impl_.success_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint64 accountId = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _impl_.accountid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* S_EnterGame::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:Protocol.S_EnterGame)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // bool success = 1;
  if (this->_internal_success() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(1, this->_internal_success(), target);
  }

  // uint64 accountId = 2;
  if (this->_internal_accountid() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(2, this->_internal_accountid(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:Protocol.S_EnterGame)
  return target;
}

size_t S_EnterGame::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:Protocol.S_EnterGame)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // uint64 accountId = 2;
  if (this->_internal_accountid() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_accountid());
  }

  // bool success = 1;
  if (this->_internal_success() != 0) {
    total_size += 1 + 1;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData S_EnterGame::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    S_EnterGame::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*S_EnterGame::GetClassData() const { return &_class_data_; }


void S_EnterGame::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<S_EnterGame*>(&to_msg);
  auto& from = static_cast<const S_EnterGame&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:Protocol.S_EnterGame)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_accountid() != 0) {
    _this->_internal_set_accountid(from._internal_accountid());
  }
  if (from._internal_success() != 0) {
    _this->_internal_set_success(from._internal_success());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void S_EnterGame::CopyFrom(const S_EnterGame& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:Protocol.S_EnterGame)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool S_EnterGame::IsInitialized() const {
  return true;
}

void S_EnterGame::InternalSwap(S_EnterGame* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(S_EnterGame, _impl_.success_)
      + sizeof(S_EnterGame::_impl_.success_)
      - PROTOBUF_FIELD_OFFSET(S_EnterGame, _impl_.accountid_)>(
          reinterpret_cast<char*>(&_impl_.accountid_),
          reinterpret_cast<char*>(&other->_impl_.accountid_));
}

::PROTOBUF_NAMESPACE_ID::Metadata S_EnterGame::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_Protocol_2eproto_getter, &descriptor_table_Protocol_2eproto_once,
      file_level_metadata_Protocol_2eproto[1]);
}

// ===================================================================

class S_MyPlayer::_Internal {
 public:
  static const ::Protocol::ObjectInfo& info(const S_MyPlayer* msg);
};

const ::Protocol::ObjectInfo&
S_MyPlayer::_Internal::info(const S_MyPlayer* msg) {
  return *msg->_impl_.info_;
}
void S_MyPlayer::clear_info() {
  if (GetArenaForAllocation() == nullptr && _impl_.info_ != nullptr) {
    delete _impl_.info_;
  }
  _impl_.info_ = nullptr;
}
S_MyPlayer::S_MyPlayer(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:Protocol.S_MyPlayer)
}
S_MyPlayer::S_MyPlayer(const S_MyPlayer& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  S_MyPlayer* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.info_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_info()) {
    _this->_impl_.info_ = new ::Protocol::ObjectInfo(*from._impl_.info_);
  }
  // @@protoc_insertion_point(copy_constructor:Protocol.S_MyPlayer)
}

inline void S_MyPlayer::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.info_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

S_MyPlayer::~S_MyPlayer() {
  // @@protoc_insertion_point(destructor:Protocol.S_MyPlayer)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void S_MyPlayer::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.info_;
}

void S_MyPlayer::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void S_MyPlayer::Clear() {
// @@protoc_insertion_point(message_clear_start:Protocol.S_MyPlayer)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (GetArenaForAllocation() == nullptr && _impl_.info_ != nullptr) {
    delete _impl_.info_;
  }
  _impl_.info_ = nullptr;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* S_MyPlayer::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .Protocol.ObjectInfo info = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_info(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* S_MyPlayer::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:Protocol.S_MyPlayer)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .Protocol.ObjectInfo info = 1;
  if (this->_internal_has_info()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::info(this),
        _Internal::info(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:Protocol.S_MyPlayer)
  return target;
}

size_t S_MyPlayer::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:Protocol.S_MyPlayer)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .Protocol.ObjectInfo info = 1;
  if (this->_internal_has_info()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.info_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData S_MyPlayer::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    S_MyPlayer::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*S_MyPlayer::GetClassData() const { return &_class_data_; }


void S_MyPlayer::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<S_MyPlayer*>(&to_msg);
  auto& from = static_cast<const S_MyPlayer&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:Protocol.S_MyPlayer)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_info()) {
    _this->_internal_mutable_info()->::Protocol::ObjectInfo::MergeFrom(
        from._internal_info());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void S_MyPlayer::CopyFrom(const S_MyPlayer& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:Protocol.S_MyPlayer)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool S_MyPlayer::IsInitialized() const {
  return true;
}

void S_MyPlayer::InternalSwap(S_MyPlayer* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_.info_, other->_impl_.info_);
}

::PROTOBUF_NAMESPACE_ID::Metadata S_MyPlayer::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_Protocol_2eproto_getter, &descriptor_table_Protocol_2eproto_once,
      file_level_metadata_Protocol_2eproto[2]);
}

// ===================================================================

class S_AddObject::_Internal {
 public:
};

void S_AddObject::clear_objects() {
  _impl_.objects_.Clear();
}
S_AddObject::S_AddObject(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:Protocol.S_AddObject)
}
S_AddObject::S_AddObject(const S_AddObject& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  S_AddObject* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.objects_){from._impl_.objects_}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:Protocol.S_AddObject)
}

inline void S_AddObject::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.objects_){arena}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

S_AddObject::~S_AddObject() {
  // @@protoc_insertion_point(destructor:Protocol.S_AddObject)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void S_AddObject::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.objects_.~RepeatedPtrField();
}

void S_AddObject::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void S_AddObject::Clear() {
// @@protoc_insertion_point(message_clear_start:Protocol.S_AddObject)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.objects_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* S_AddObject::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .Protocol.ObjectInfo objects = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_objects(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* S_AddObject::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:Protocol.S_AddObject)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .Protocol.ObjectInfo objects = 1;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_objects_size()); i < n; i++) {
    const auto& repfield = this->_internal_objects(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:Protocol.S_AddObject)
  return target;
}

size_t S_AddObject::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:Protocol.S_AddObject)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .Protocol.ObjectInfo objects = 1;
  total_size += 1UL * this->_internal_objects_size();
  for (const auto& msg : this->_impl_.objects_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData S_AddObject::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    S_AddObject::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*S_AddObject::GetClassData() const { return &_class_data_; }


void S_AddObject::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<S_AddObject*>(&to_msg);
  auto& from = static_cast<const S_AddObject&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:Protocol.S_AddObject)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.objects_.MergeFrom(from._impl_.objects_);
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void S_AddObject::CopyFrom(const S_AddObject& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:Protocol.S_AddObject)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool S_AddObject::IsInitialized() const {
  return true;
}

void S_AddObject::InternalSwap(S_AddObject* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.objects_.InternalSwap(&other->_impl_.objects_);
}

::PROTOBUF_NAMESPACE_ID::Metadata S_AddObject::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_Protocol_2eproto_getter, &descriptor_table_Protocol_2eproto_once,
      file_level_metadata_Protocol_2eproto[3]);
}

// ===================================================================

class S_RemoveObject::_Internal {
 public:
};

S_RemoveObject::S_RemoveObject(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:Protocol.S_RemoveObject)
}
S_RemoveObject::S_RemoveObject(const S_RemoveObject& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  S_RemoveObject* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.ids_){from._impl_.ids_}
    , /*decltype(_impl_._ids_cached_byte_size_)*/{0}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:Protocol.S_RemoveObject)
}

inline void S_RemoveObject::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.ids_){arena}
    , /*decltype(_impl_._ids_cached_byte_size_)*/{0}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

S_RemoveObject::~S_RemoveObject() {
  // @@protoc_insertion_point(destructor:Protocol.S_RemoveObject)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void S_RemoveObject::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.ids_.~RepeatedField();
}

void S_RemoveObject::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void S_RemoveObject::Clear() {
// @@protoc_insertion_point(message_clear_start:Protocol.S_RemoveObject)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.ids_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* S_RemoveObject::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated uint64 ids = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedUInt64Parser(_internal_mutable_ids(), ptr, ctx);
          CHK_(ptr);
        } else if (static_cast<uint8_t>(tag) == 8) {
          _internal_add_ids(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* S_RemoveObject::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:Protocol.S_RemoveObject)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated uint64 ids = 1;
  {
    int byte_size = _impl_._ids_cached_byte_size_.load(std::memory_order_relaxed);
    if (byte_size > 0) {
      target = stream->WriteUInt64Packed(
          1, _internal_ids(), byte_size, target);
    }
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:Protocol.S_RemoveObject)
  return target;
}

size_t S_RemoveObject::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:Protocol.S_RemoveObject)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated uint64 ids = 1;
  {
    size_t data_size = ::_pbi::WireFormatLite::
      UInt64Size(this->_impl_.ids_);
    if (data_size > 0) {
      total_size += 1 +
        ::_pbi::WireFormatLite::Int32Size(static_cast<int32_t>(data_size));
    }
    int cached_size = ::_pbi::ToCachedSize(data_size);
    _impl_._ids_cached_byte_size_.store(cached_size,
                                    std::memory_order_relaxed);
    total_size += data_size;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData S_RemoveObject::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    S_RemoveObject::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*S_RemoveObject::GetClassData() const { return &_class_data_; }


void S_RemoveObject::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<S_RemoveObject*>(&to_msg);
  auto& from = static_cast<const S_RemoveObject&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:Protocol.S_RemoveObject)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.ids_.MergeFrom(from._impl_.ids_);
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void S_RemoveObject::CopyFrom(const S_RemoveObject& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:Protocol.S_RemoveObject)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool S_RemoveObject::IsInitialized() const {
  return true;
}

void S_RemoveObject::InternalSwap(S_RemoveObject* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.ids_.InternalSwap(&other->_impl_.ids_);
}

::PROTOBUF_NAMESPACE_ID::Metadata S_RemoveObject::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_Protocol_2eproto_getter, &descriptor_table_Protocol_2eproto_once,
      file_level_metadata_Protocol_2eproto[4]);
}

// ===================================================================

class C_Move::_Internal {
 public:
};

C_Move::C_Move(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:Protocol.C_Move)
}
C_Move::C_Move(const C_Move& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  C_Move* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.dir_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _this->_impl_.dir_ = from._impl_.dir_;
  // @@protoc_insertion_point(copy_constructor:Protocol.C_Move)
}

inline void C_Move::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.dir_){0}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

C_Move::~C_Move() {
  // @@protoc_insertion_point(destructor:Protocol.C_Move)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void C_Move::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void C_Move::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void C_Move::Clear() {
// @@protoc_insertion_point(message_clear_start:Protocol.C_Move)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.dir_ = 0;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* C_Move::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .Protocol.DIR_TYPE dir = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_dir(static_cast<::Protocol::DIR_TYPE>(val));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* C_Move::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:Protocol.C_Move)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .Protocol.DIR_TYPE dir = 1;
  if (this->_internal_dir() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      1, this->_internal_dir(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:Protocol.C_Move)
  return target;
}

size_t C_Move::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:Protocol.C_Move)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .Protocol.DIR_TYPE dir = 1;
  if (this->_internal_dir() != 0) {
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_dir());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData C_Move::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    C_Move::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*C_Move::GetClassData() const { return &_class_data_; }


void C_Move::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<C_Move*>(&to_msg);
  auto& from = static_cast<const C_Move&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:Protocol.C_Move)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_dir() != 0) {
    _this->_internal_set_dir(from._internal_dir());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void C_Move::CopyFrom(const C_Move& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:Protocol.C_Move)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool C_Move::IsInitialized() const {
  return true;
}

void C_Move::InternalSwap(C_Move* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_.dir_, other->_impl_.dir_);
}

::PROTOBUF_NAMESPACE_ID::Metadata C_Move::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_Protocol_2eproto_getter, &descriptor_table_Protocol_2eproto_once,
      file_level_metadata_Protocol_2eproto[5]);
}

// ===================================================================

class S_Move::_Internal {
 public:
  static const ::Protocol::ObjectInfo& info(const S_Move* msg);
};

const ::Protocol::ObjectInfo&
S_Move::_Internal::info(const S_Move* msg) {
  return *msg->_impl_.info_;
}
void S_Move::clear_info() {
  if (GetArenaForAllocation() == nullptr && _impl_.info_ != nullptr) {
    delete _impl_.info_;
  }
  _impl_.info_ = nullptr;
}
S_Move::S_Move(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:Protocol.S_Move)
}
S_Move::S_Move(const S_Move& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  S_Move* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.info_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_info()) {
    _this->_impl_.info_ = new ::Protocol::ObjectInfo(*from._impl_.info_);
  }
  // @@protoc_insertion_point(copy_constructor:Protocol.S_Move)
}

inline void S_Move::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.info_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

S_Move::~S_Move() {
  // @@protoc_insertion_point(destructor:Protocol.S_Move)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void S_Move::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.info_;
}

void S_Move::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void S_Move::Clear() {
// @@protoc_insertion_point(message_clear_start:Protocol.S_Move)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (GetArenaForAllocation() == nullptr && _impl_.info_ != nullptr) {
    delete _impl_.info_;
  }
  _impl_.info_ = nullptr;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* S_Move::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .Protocol.ObjectInfo info = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_info(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* S_Move::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:Protocol.S_Move)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .Protocol.ObjectInfo info = 1;
  if (this->_internal_has_info()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::info(this),
        _Internal::info(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:Protocol.S_Move)
  return target;
}

size_t S_Move::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:Protocol.S_Move)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .Protocol.ObjectInfo info = 1;
  if (this->_internal_has_info()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.info_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData S_Move::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    S_Move::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*S_Move::GetClassData() const { return &_class_data_; }


void S_Move::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<S_Move*>(&to_msg);
  auto& from = static_cast<const S_Move&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:Protocol.S_Move)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_info()) {
    _this->_internal_mutable_info()->::Protocol::ObjectInfo::MergeFrom(
        from._internal_info());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void S_Move::CopyFrom(const S_Move& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:Protocol.S_Move)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool S_Move::IsInitialized() const {
  return true;
}

void S_Move::InternalSwap(S_Move* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_.info_, other->_impl_.info_);
}

::PROTOBUF_NAMESPACE_ID::Metadata S_Move::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_Protocol_2eproto_getter, &descriptor_table_Protocol_2eproto_once,
      file_level_metadata_Protocol_2eproto[6]);
}

// ===================================================================

class C_Turn::_Internal {
 public:
};

C_Turn::C_Turn(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:Protocol.C_Turn)
}
C_Turn::C_Turn(const C_Turn& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  C_Turn* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.dir_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _this->_impl_.dir_ = from._impl_.dir_;
  // @@protoc_insertion_point(copy_constructor:Protocol.C_Turn)
}

inline void C_Turn::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.dir_){0}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

C_Turn::~C_Turn() {
  // @@protoc_insertion_point(destructor:Protocol.C_Turn)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void C_Turn::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void C_Turn::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void C_Turn::Clear() {
// @@protoc_insertion_point(message_clear_start:Protocol.C_Turn)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.dir_ = 0;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* C_Turn::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .Protocol.DIR_TYPE dir = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_dir(static_cast<::Protocol::DIR_TYPE>(val));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* C_Turn::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:Protocol.C_Turn)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .Protocol.DIR_TYPE dir = 1;
  if (this->_internal_dir() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      1, this->_internal_dir(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:Protocol.C_Turn)
  return target;
}

size_t C_Turn::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:Protocol.C_Turn)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .Protocol.DIR_TYPE dir = 1;
  if (this->_internal_dir() != 0) {
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_dir());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData C_Turn::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    C_Turn::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*C_Turn::GetClassData() const { return &_class_data_; }


void C_Turn::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<C_Turn*>(&to_msg);
  auto& from = static_cast<const C_Turn&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:Protocol.C_Turn)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_dir() != 0) {
    _this->_internal_set_dir(from._internal_dir());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void C_Turn::CopyFrom(const C_Turn& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:Protocol.C_Turn)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool C_Turn::IsInitialized() const {
  return true;
}

void C_Turn::InternalSwap(C_Turn* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_.dir_, other->_impl_.dir_);
}

::PROTOBUF_NAMESPACE_ID::Metadata C_Turn::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_Protocol_2eproto_getter, &descriptor_table_Protocol_2eproto_once,
      file_level_metadata_Protocol_2eproto[7]);
}

// ===================================================================

class S_Turn::_Internal {
 public:
  static const ::Protocol::ObjectInfo& info(const S_Turn* msg);
};

const ::Protocol::ObjectInfo&
S_Turn::_Internal::info(const S_Turn* msg) {
  return *msg->_impl_.info_;
}
void S_Turn::clear_info() {
  if (GetArenaForAllocation() == nullptr && _impl_.info_ != nullptr) {
    delete _impl_.info_;
  }
  _impl_.info_ = nullptr;
}
S_Turn::S_Turn(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:Protocol.S_Turn)
}
S_Turn::S_Turn(const S_Turn& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  S_Turn* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.info_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_info()) {
    _this->_impl_.info_ = new ::Protocol::ObjectInfo(*from._impl_.info_);
  }
  // @@protoc_insertion_point(copy_constructor:Protocol.S_Turn)
}

inline void S_Turn::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.info_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

S_Turn::~S_Turn() {
  // @@protoc_insertion_point(destructor:Protocol.S_Turn)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void S_Turn::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.info_;
}

void S_Turn::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void S_Turn::Clear() {
// @@protoc_insertion_point(message_clear_start:Protocol.S_Turn)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (GetArenaForAllocation() == nullptr && _impl_.info_ != nullptr) {
    delete _impl_.info_;
  }
  _impl_.info_ = nullptr;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* S_Turn::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .Protocol.ObjectInfo info = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_info(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* S_Turn::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:Protocol.S_Turn)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .Protocol.ObjectInfo info = 1;
  if (this->_internal_has_info()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::info(this),
        _Internal::info(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:Protocol.S_Turn)
  return target;
}

size_t S_Turn::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:Protocol.S_Turn)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .Protocol.ObjectInfo info = 1;
  if (this->_internal_has_info()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.info_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData S_Turn::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    S_Turn::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*S_Turn::GetClassData() const { return &_class_data_; }


void S_Turn::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<S_Turn*>(&to_msg);
  auto& from = static_cast<const S_Turn&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:Protocol.S_Turn)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_info()) {
    _this->_internal_mutable_info()->::Protocol::ObjectInfo::MergeFrom(
        from._internal_info());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void S_Turn::CopyFrom(const S_Turn& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:Protocol.S_Turn)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool S_Turn::IsInitialized() const {
  return true;
}

void S_Turn::InternalSwap(S_Turn* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_.info_, other->_impl_.info_);
}

::PROTOBUF_NAMESPACE_ID::Metadata S_Turn::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_Protocol_2eproto_getter, &descriptor_table_Protocol_2eproto_once,
      file_level_metadata_Protocol_2eproto[8]);
}

// ===================================================================

class C_Attack::_Internal {
 public:
};

C_Attack::C_Attack(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:Protocol.C_Attack)
}
C_Attack::C_Attack(const C_Attack& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  C_Attack* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.dir_){}
    , decltype(_impl_.weapontype_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.dir_, &from._impl_.dir_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.weapontype_) -
    reinterpret_cast<char*>(&_impl_.dir_)) + sizeof(_impl_.weapontype_));
  // @@protoc_insertion_point(copy_constructor:Protocol.C_Attack)
}

inline void C_Attack::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.dir_){0}
    , decltype(_impl_.weapontype_){0}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

C_Attack::~C_Attack() {
  // @@protoc_insertion_point(destructor:Protocol.C_Attack)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void C_Attack::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void C_Attack::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void C_Attack::Clear() {
// @@protoc_insertion_point(message_clear_start:Protocol.C_Attack)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::memset(&_impl_.dir_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.weapontype_) -
      reinterpret_cast<char*>(&_impl_.dir_)) + sizeof(_impl_.weapontype_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* C_Attack::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .Protocol.DIR_TYPE dir = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_dir(static_cast<::Protocol::DIR_TYPE>(val));
        } else
          goto handle_unusual;
        continue;
      // .Protocol.WEAPON_TYPE weaponType = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_weapontype(static_cast<::Protocol::WEAPON_TYPE>(val));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* C_Attack::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:Protocol.C_Attack)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .Protocol.DIR_TYPE dir = 1;
  if (this->_internal_dir() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      1, this->_internal_dir(), target);
  }

  // .Protocol.WEAPON_TYPE weaponType = 2;
  if (this->_internal_weapontype() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      2, this->_internal_weapontype(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:Protocol.C_Attack)
  return target;
}

size_t C_Attack::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:Protocol.C_Attack)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .Protocol.DIR_TYPE dir = 1;
  if (this->_internal_dir() != 0) {
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_dir());
  }

  // .Protocol.WEAPON_TYPE weaponType = 2;
  if (this->_internal_weapontype() != 0) {
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_weapontype());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData C_Attack::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    C_Attack::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*C_Attack::GetClassData() const { return &_class_data_; }


void C_Attack::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<C_Attack*>(&to_msg);
  auto& from = static_cast<const C_Attack&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:Protocol.C_Attack)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_dir() != 0) {
    _this->_internal_set_dir(from._internal_dir());
  }
  if (from._internal_weapontype() != 0) {
    _this->_internal_set_weapontype(from._internal_weapontype());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void C_Attack::CopyFrom(const C_Attack& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:Protocol.C_Attack)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool C_Attack::IsInitialized() const {
  return true;
}

void C_Attack::InternalSwap(C_Attack* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(C_Attack, _impl_.weapontype_)
      + sizeof(C_Attack::_impl_.weapontype_)
      - PROTOBUF_FIELD_OFFSET(C_Attack, _impl_.dir_)>(
          reinterpret_cast<char*>(&_impl_.dir_),
          reinterpret_cast<char*>(&other->_impl_.dir_));
}

::PROTOBUF_NAMESPACE_ID::Metadata C_Attack::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_Protocol_2eproto_getter, &descriptor_table_Protocol_2eproto_once,
      file_level_metadata_Protocol_2eproto[9]);
}

// ===================================================================

class S_Attack::_Internal {
 public:
};

S_Attack::S_Attack(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:Protocol.S_Attack)
}
S_Attack::S_Attack(const S_Attack& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  S_Attack* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.attackerid_){}
    , decltype(_impl_.dir_){}
    , decltype(_impl_.weapontype_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.attackerid_, &from._impl_.attackerid_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.weapontype_) -
    reinterpret_cast<char*>(&_impl_.attackerid_)) + sizeof(_impl_.weapontype_));
  // @@protoc_insertion_point(copy_constructor:Protocol.S_Attack)
}

inline void S_Attack::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.attackerid_){uint64_t{0u}}
    , decltype(_impl_.dir_){0}
    , decltype(_impl_.weapontype_){0}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

S_Attack::~S_Attack() {
  // @@protoc_insertion_point(destructor:Protocol.S_Attack)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void S_Attack::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void S_Attack::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void S_Attack::Clear() {
// @@protoc_insertion_point(message_clear_start:Protocol.S_Attack)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::memset(&_impl_.attackerid_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.weapontype_) -
      reinterpret_cast<char*>(&_impl_.attackerid_)) + sizeof(_impl_.weapontype_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* S_Attack::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // uint64 attackerId = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _impl_.attackerid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .Protocol.DIR_TYPE dir = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_dir(static_cast<::Protocol::DIR_TYPE>(val));
        } else
          goto handle_unusual;
        continue;
      // .Protocol.WEAPON_TYPE weaponType = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_weapontype(static_cast<::Protocol::WEAPON_TYPE>(val));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* S_Attack::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:Protocol.S_Attack)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // uint64 attackerId = 1;
  if (this->_internal_attackerid() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(1, this->_internal_attackerid(), target);
  }

  // .Protocol.DIR_TYPE dir = 2;
  if (this->_internal_dir() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      2, this->_internal_dir(), target);
  }

  // .Protocol.WEAPON_TYPE weaponType = 3;
  if (this->_internal_weapontype() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      3, this->_internal_weapontype(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:Protocol.S_Attack)
  return target;
}

size_t S_Attack::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:Protocol.S_Attack)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // uint64 attackerId = 1;
  if (this->_internal_attackerid() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_attackerid());
  }

  // .Protocol.DIR_TYPE dir = 2;
  if (this->_internal_dir() != 0) {
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_dir());
  }

  // .Protocol.WEAPON_TYPE weaponType = 3;
  if (this->_internal_weapontype() != 0) {
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_weapontype());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData S_Attack::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    S_Attack::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*S_Attack::GetClassData() const { return &_class_data_; }


void S_Attack::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<S_Attack*>(&to_msg);
  auto& from = static_cast<const S_Attack&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:Protocol.S_Attack)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_attackerid() != 0) {
    _this->_internal_set_attackerid(from._internal_attackerid());
  }
  if (from._internal_dir() != 0) {
    _this->_internal_set_dir(from._internal_dir());
  }
  if (from._internal_weapontype() != 0) {
    _this->_internal_set_weapontype(from._internal_weapontype());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void S_Attack::CopyFrom(const S_Attack& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:Protocol.S_Attack)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool S_Attack::IsInitialized() const {
  return true;
}

void S_Attack::InternalSwap(S_Attack* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(S_Attack, _impl_.weapontype_)
      + sizeof(S_Attack::_impl_.weapontype_)
      - PROTOBUF_FIELD_OFFSET(S_Attack, _impl_.attackerid_)>(
          reinterpret_cast<char*>(&_impl_.attackerid_),
          reinterpret_cast<char*>(&other->_impl_.attackerid_));
}

::PROTOBUF_NAMESPACE_ID::Metadata S_Attack::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_Protocol_2eproto_getter, &descriptor_table_Protocol_2eproto_once,
      file_level_metadata_Protocol_2eproto[10]);
}

// ===================================================================

class S_Damaged::_Internal {
 public:
};

S_Damaged::S_Damaged(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:Protocol.S_Damaged)
}
S_Damaged::S_Damaged(const S_Damaged& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  S_Damaged* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.attackerid_){}
    , decltype(_impl_.targetid_){}
    , decltype(_impl_.newhp_){}
    , decltype(_impl_.damage_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.attackerid_, &from._impl_.attackerid_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.damage_) -
    reinterpret_cast<char*>(&_impl_.attackerid_)) + sizeof(_impl_.damage_));
  // @@protoc_insertion_point(copy_constructor:Protocol.S_Damaged)
}

inline void S_Damaged::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.attackerid_){uint64_t{0u}}
    , decltype(_impl_.targetid_){uint64_t{0u}}
    , decltype(_impl_.newhp_){0}
    , decltype(_impl_.damage_){0}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

S_Damaged::~S_Damaged() {
  // @@protoc_insertion_point(destructor:Protocol.S_Damaged)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void S_Damaged::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void S_Damaged::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void S_Damaged::Clear() {
// @@protoc_insertion_point(message_clear_start:Protocol.S_Damaged)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::memset(&_impl_.attackerid_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.damage_) -
      reinterpret_cast<char*>(&_impl_.attackerid_)) + sizeof(_impl_.damage_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* S_Damaged::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // uint64 attackerId = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _impl_.attackerid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint64 targetId = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _impl_.targetid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // int32 newHp = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _impl_.newhp_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // int32 damage = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _impl_.damage_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* S_Damaged::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:Protocol.S_Damaged)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // uint64 attackerId = 1;
  if (this->_internal_attackerid() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(1, this->_internal_attackerid(), target);
  }

  // uint64 targetId = 2;
  if (this->_internal_targetid() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(2, this->_internal_targetid(), target);
  }

  // int32 newHp = 3;
  if (this->_internal_newhp() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(3, this->_internal_newhp(), target);
  }

  // int32 damage = 4;
  if (this->_internal_damage() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(4, this->_internal_damage(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:Protocol.S_Damaged)
  return target;
}

size_t S_Damaged::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:Protocol.S_Damaged)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // uint64 attackerId = 1;
  if (this->_internal_attackerid() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_attackerid());
  }

  // uint64 targetId = 2;
  if (this->_internal_targetid() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_targetid());
  }

  // int32 newHp = 3;
  if (this->_internal_newhp() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_newhp());
  }

  // int32 damage = 4;
  if (this->_internal_damage() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_damage());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData S_Damaged::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    S_Damaged::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*S_Damaged::GetClassData() const { return &_class_data_; }


void S_Damaged::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<S_Damaged*>(&to_msg);
  auto& from = static_cast<const S_Damaged&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:Protocol.S_Damaged)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_attackerid() != 0) {
    _this->_internal_set_attackerid(from._internal_attackerid());
  }
  if (from._internal_targetid() != 0) {
    _this->_internal_set_targetid(from._internal_targetid());
  }
  if (from._internal_newhp() != 0) {
    _this->_internal_set_newhp(from._internal_newhp());
  }
  if (from._internal_damage() != 0) {
    _this->_internal_set_damage(from._internal_damage());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void S_Damaged::CopyFrom(const S_Damaged& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:Protocol.S_Damaged)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool S_Damaged::IsInitialized() const {
  return true;
}

void S_Damaged::InternalSwap(S_Damaged* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(S_Damaged, _impl_.damage_)
      + sizeof(S_Damaged::_impl_.damage_)
      - PROTOBUF_FIELD_OFFSET(S_Damaged, _impl_.attackerid_)>(
          reinterpret_cast<char*>(&_impl_.attackerid_),
          reinterpret_cast<char*>(&other->_impl_.attackerid_));
}

::PROTOBUF_NAMESPACE_ID::Metadata S_Damaged::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_Protocol_2eproto_getter, &descriptor_table_Protocol_2eproto_once,
      file_level_metadata_Protocol_2eproto[11]);
}

// ===================================================================

class C_ChangeMap::_Internal {
 public:
};

C_ChangeMap::C_ChangeMap(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:Protocol.C_ChangeMap)
}
C_ChangeMap::C_ChangeMap(const C_ChangeMap& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  C_ChangeMap* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.mapid_){}
    , decltype(_impl_.channel_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.mapid_, &from._impl_.mapid_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.channel_) -
    reinterpret_cast<char*>(&_impl_.mapid_)) + sizeof(_impl_.channel_));
  // @@protoc_insertion_point(copy_constructor:Protocol.C_ChangeMap)
}

inline void C_ChangeMap::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.mapid_){0}
    , decltype(_impl_.channel_){0}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

C_ChangeMap::~C_ChangeMap() {
  // @@protoc_insertion_point(destructor:Protocol.C_ChangeMap)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void C_ChangeMap::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void C_ChangeMap::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void C_ChangeMap::Clear() {
// @@protoc_insertion_point(message_clear_start:Protocol.C_ChangeMap)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::memset(&_impl_.mapid_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.channel_) -
      reinterpret_cast<char*>(&_impl_.mapid_)) + sizeof(_impl_.channel_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* C_ChangeMap::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .Protocol.MAP_ID mapId = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_mapid(static_cast<::Protocol::MAP_ID>(val));
        } else
          goto handle_unusual;
        continue;
      // int32 channel = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _impl_.channel_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* C_ChangeMap::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:Protocol.C_ChangeMap)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .Protocol.MAP_ID mapId = 1;
  if (this->_internal_mapid() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      1, this->_internal_mapid(), target);
  }

  // int32 channel = 2;
  if (this->_internal_channel() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(2, this->_internal_channel(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:Protocol.C_ChangeMap)
  return target;
}

size_t C_ChangeMap::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:Protocol.C_ChangeMap)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .Protocol.MAP_ID mapId = 1;
  if (this->_internal_mapid() != 0) {
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_mapid());
  }

  // int32 channel = 2;
  if (this->_internal_channel() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_channel());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData C_ChangeMap::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    C_ChangeMap::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*C_ChangeMap::GetClassData() const { return &_class_data_; }


void C_ChangeMap::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<C_ChangeMap*>(&to_msg);
  auto& from = static_cast<const C_ChangeMap&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:Protocol.C_ChangeMap)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_mapid() != 0) {
    _this->_internal_set_mapid(from._internal_mapid());
  }
  if (from._internal_channel() != 0) {
    _this->_internal_set_channel(from._internal_channel());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void C_ChangeMap::CopyFrom(const C_ChangeMap& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:Protocol.C_ChangeMap)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool C_ChangeMap::IsInitialized() const {
  return true;
}

void C_ChangeMap::InternalSwap(C_ChangeMap* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(C_ChangeMap, _impl_.channel_)
      + sizeof(C_ChangeMap::_impl_.channel_)
      - PROTOBUF_FIELD_OFFSET(C_ChangeMap, _impl_.mapid_)>(
          reinterpret_cast<char*>(&_impl_.mapid_),
          reinterpret_cast<char*>(&other->_impl_.mapid_));
}

::PROTOBUF_NAMESPACE_ID::Metadata C_ChangeMap::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_Protocol_2eproto_getter, &descriptor_table_Protocol_2eproto_once,
      file_level_metadata_Protocol_2eproto[12]);
}

// ===================================================================

class S_ChangeMap::_Internal {
 public:
};

S_ChangeMap::S_ChangeMap(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:Protocol.S_ChangeMap)
}
S_ChangeMap::S_ChangeMap(const S_ChangeMap& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  S_ChangeMap* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.success_){}
    , decltype(_impl_.mapid_){}
    , decltype(_impl_.instanceid_){}
    , decltype(_impl_.channel_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.success_, &from._impl_.success_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.channel_) -
    reinterpret_cast<char*>(&_impl_.success_)) + sizeof(_impl_.channel_));
  // @@protoc_insertion_point(copy_constructor:Protocol.S_ChangeMap)
}

inline void S_ChangeMap::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.success_){false}
    , decltype(_impl_.mapid_){0}
    , decltype(_impl_.instanceid_){uint64_t{0u}}
    , decltype(_impl_.channel_){0}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

S_ChangeMap::~S_ChangeMap() {
  // @@protoc_insertion_point(destructor:Protocol.S_ChangeMap)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void S_ChangeMap::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void S_ChangeMap::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void S_ChangeMap::Clear() {
// @@protoc_insertion_point(message_clear_start:Protocol.S_ChangeMap)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::memset(&_impl_.success_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.channel_) -
      reinterpret_cast<char*>(&_impl_.success_)) + sizeof(_impl_.channel_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* S_ChangeMap::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // bool success = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _impl_.success_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .Protocol.MAP_ID mapId = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_mapid(static_cast<::Protocol::MAP_ID>(val));
        } else
          goto handle_unusual;
        continue;
      // int32 channel = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _impl_.channel_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint64 instanceId = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _impl_.instanceid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* S_ChangeMap::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:Protocol.S_ChangeMap)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // bool success = 1;
  if (this->_internal_success() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(1, this->_internal_success(), target);
  }

  // .Protocol.MAP_ID mapId = 2;
  if (this->_internal_mapid() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      2, this->_internal_mapid(), target);
  }

  // int32 channel = 3;
  if (this->_internal_channel() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(3, this->_internal_channel(), target);
  }

  // uint64 instanceId = 4;
  if (this->_internal_instanceid() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(4, this->_internal_instanceid(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:Protocol.S_ChangeMap)
  return target;
}

size_t S_ChangeMap::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:Protocol.S_ChangeMap)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // bool success = 1;
  if (this->_internal_success() != 0) {
    total_size += 1 + 1;
  }

  // .Protocol.MAP_ID mapId = 2;
  if (this->_internal_mapid() != 0) {
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_mapid());
  }

  // uint64 instanceId = 4;
  if (this->_internal_instanceid() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_instanceid());
  }

  // int32 channel = 3;
  if (this->_internal_channel() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_channel());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData S_ChangeMap::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    S_ChangeMap::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*S_ChangeMap::GetClassData() const { return &_class_data_; }


void S_ChangeMap::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<S_ChangeMap*>(&to_msg);
  auto& from = static_cast<const S_ChangeMap&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:Protocol.S_ChangeMap)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_success() != 0) {
    _this->_internal_set_success(from._internal_success());
  }
  if (from._internal_mapid() != 0) {
    _this->_internal_set_mapid(from._internal_mapid());
  }
  if (from._internal_instanceid() != 0) {
    _this->_internal_set_instanceid(from._internal_instanceid());
  }
  if (from._internal_channel() != 0) {
    _this->_internal_set_channel(from._internal_channel());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void S_ChangeMap::CopyFrom(const S_ChangeMap& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:Protocol.S_ChangeMap)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool S_ChangeMap::IsInitialized() const {
  return true;
}

void S_ChangeMap::InternalSwap(S_ChangeMap* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(S_ChangeMap, _impl_.channel_)
      + sizeof(S_ChangeMap::_impl_.channel_)
      - PROTOBUF_FIELD_OFFSET(S_ChangeMap, _impl_.success_)>(
          reinterpret_cast<char*>(&_impl_.success_),
          reinterpret_cast<char*>(&other->_impl_.success_));
}

::PROTOBUF_NAMESPACE_ID::Metadata S_ChangeMap::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_Protocol_2eproto_getter, &descriptor_table_Protocol_2eproto_once,
      file_level_metadata_Protocol_2eproto[13]);
}

// ===================================================================

class S_GainExp::_Internal {
 public:
};

S_GainExp::S_GainExp(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:Protocol.S_GainExp)
}
S_GainExp::S_GainExp(const S_GainExp& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  S_GainExp* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.playerid_){}
    , decltype(_impl_.gainedexp_){}
    , decltype(_impl_.currentexp_){}
    , decltype(_impl_.maxexp_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.playerid_, &from._impl_.playerid_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.maxexp_) -
    reinterpret_cast<char*>(&_impl_.playerid_)) + sizeof(_impl_.maxexp_));
  // @@protoc_insertion_point(copy_constructor:Protocol.S_GainExp)
}

inline void S_GainExp::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.playerid_){uint64_t{0u}}
    , decltype(_impl_.gainedexp_){0}
    , decltype(_impl_.currentexp_){0}
    , decltype(_impl_.maxexp_){0}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

S_GainExp::~S_GainExp() {
  // @@protoc_insertion_point(destructor:Protocol.S_GainExp)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void S_GainExp::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void S_GainExp::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void S_GainExp::Clear() {
// @@protoc_insertion_point(message_clear_start:Protocol.S_GainExp)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::memset(&_impl_.playerid_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.maxexp_) -
      reinterpret_cast<char*>(&_impl_.playerid_)) + sizeof(_impl_.maxexp_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* S_GainExp::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // uint64 playerId = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _impl_.playerid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // int32 gainedExp = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _impl_.gainedexp_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // int32 currentExp = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _impl_.currentexp_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // int32 maxExp = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _impl_.maxexp_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* S_GainExp::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:Protocol.S_GainExp)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // uint64 playerId = 1;
  if (this->_internal_playerid() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(1, this->_internal_playerid(), target);
  }

  // int32 gainedExp = 2;
  if (this->_internal_gainedexp() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(2, this->_internal_gainedexp(), target);
  }

  // int32 currentExp = 3;
  if (this->_internal_currentexp() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(3, this->_internal_currentexp(), target);
  }

  // int32 maxExp = 4;
  if (this->_internal_maxexp() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(4, this->_internal_maxexp(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:Protocol.S_GainExp)
  return target;
}

size_t S_GainExp::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:Protocol.S_GainExp)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // uint64 playerId = 1;
  if (this->_internal_playerid() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_playerid());
  }

  // int32 gainedExp = 2;
  if (this->_internal_gainedexp() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_gainedexp());
  }

  // int32 currentExp = 3;
  if (this->_internal_currentexp() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_currentexp());
  }

  // int32 maxExp = 4;
  if (this->_internal_maxexp() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_maxexp());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData S_GainExp::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    S_GainExp::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*S_GainExp::GetClassData() const { return &_class_data_; }


void S_GainExp::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<S_GainExp*>(&to_msg);
  auto& from = static_cast<const S_GainExp&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:Protocol.S_GainExp)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_playerid() != 0) {
    _this->_internal_set_playerid(from._internal_playerid());
  }
  if (from._internal_gainedexp() != 0) {
    _this->_internal_set_gainedexp(from._internal_gainedexp());
  }
  if (from._internal_currentexp() != 0) {
    _this->_internal_set_currentexp(from._internal_currentexp());
  }
  if (from._internal_maxexp() != 0) {
    _this->_internal_set_maxexp(from._internal_maxexp());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void S_GainExp::CopyFrom(const S_GainExp& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:Protocol.S_GainExp)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool S_GainExp::IsInitialized() const {
  return true;
}

void S_GainExp::InternalSwap(S_GainExp* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(S_GainExp, _impl_.maxexp_)
      + sizeof(S_GainExp::_impl_.maxexp_)
      - PROTOBUF_FIELD_OFFSET(S_GainExp, _impl_.playerid_)>(
          reinterpret_cast<char*>(&_impl_.playerid_),
          reinterpret_cast<char*>(&other->_impl_.playerid_));
}

::PROTOBUF_NAMESPACE_ID::Metadata S_GainExp::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_Protocol_2eproto_getter, &descriptor_table_Protocol_2eproto_once,
      file_level_metadata_Protocol_2eproto[14]);
}

// ===================================================================

class S_LevelUp::_Internal {
 public:
};

S_LevelUp::S_LevelUp(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:Protocol.S_LevelUp)
}
S_LevelUp::S_LevelUp(const S_LevelUp& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  S_LevelUp* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.playerid_){}
    , decltype(_impl_.newlevel_){}
    , decltype(_impl_.maxhp_){}
    , decltype(_impl_.attack_){}
    , decltype(_impl_.defence_){}
    , decltype(_impl_.maxexp_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.playerid_, &from._impl_.playerid_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.maxexp_) -
    reinterpret_cast<char*>(&_impl_.playerid_)) + sizeof(_impl_.maxexp_));
  // @@protoc_insertion_point(copy_constructor:Protocol.S_LevelUp)
}

inline void S_LevelUp::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.playerid_){uint64_t{0u}}
    , decltype(_impl_.newlevel_){0}
    , decltype(_impl_.maxhp_){0}
    , decltype(_impl_.attack_){0}
    , decltype(_impl_.defence_){0}
    , decltype(_impl_.maxexp_){0}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

S_LevelUp::~S_LevelUp() {
  // @@protoc_insertion_point(destructor:Protocol.S_LevelUp)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void S_LevelUp::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void S_LevelUp::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void S_LevelUp::Clear() {
// @@protoc_insertion_point(message_clear_start:Protocol.S_LevelUp)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::memset(&_impl_.playerid_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.maxexp_) -
      reinterpret_cast<char*>(&_impl_.playerid_)) + sizeof(_impl_.maxexp_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* S_LevelUp::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // uint64 playerId = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _impl_.playerid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // int32 newLevel = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _impl_.newlevel_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // int32 maxHp = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _impl_.maxhp_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // int32 attack = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _impl_.attack_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // int32 defence = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _impl_.defence_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // int32 maxExp = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          _impl_.maxexp_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* S_LevelUp::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:Protocol.S_LevelUp)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // uint64 playerId = 1;
  if (this->_internal_playerid() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(1, this->_internal_playerid(), target);
  }

  // int32 newLevel = 2;
  if (this->_internal_newlevel() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(2, this->_internal_newlevel(), target);
  }

  // int32 maxHp = 3;
  if (this->_internal_maxhp() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(3, this->_internal_maxhp(), target);
  }

  // int32 attack = 4;
  if (this->_internal_attack() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(4, this->_internal_attack(), target);
  }

  // int32 defence = 5;
  if (this->_internal_defence() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(5, this->_internal_defence(), target);
  }

  // int32 maxExp = 6;
  if (this->_internal_maxexp() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(6, this->_internal_maxexp(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:Protocol.S_LevelUp)
  return target;
}

size_t S_LevelUp::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:Protocol.S_LevelUp)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // uint64 playerId = 1;
  if (this->_internal_playerid() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_playerid());
  }

  // int32 newLevel = 2;
  if (this->_internal_newlevel() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_newlevel());
  }

  // int32 maxHp = 3;
  if (this->_internal_maxhp() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_maxhp());
  }

  // int32 attack = 4;
  if (this->_internal_attack() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_attack());
  }

  // int32 defence = 5;
  if (this->_internal_defence() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_defence());
  }

  // int32 maxExp = 6;
  if (this->_internal_maxexp() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_maxexp());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData S_LevelUp::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    S_LevelUp::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*S_LevelUp::GetClassData() const { return &_class_data_; }


void S_LevelUp::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<S_LevelUp*>(&to_msg);
  auto& from = static_cast<const S_LevelUp&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:Protocol.S_LevelUp)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_playerid() != 0) {
    _this->_internal_set_playerid(from._internal_playerid());
  }
  if (from._internal_newlevel() != 0) {
    _this->_internal_set_newlevel(from._internal_newlevel());
  }
  if (from._internal_maxhp() != 0) {
    _this->_internal_set_maxhp(from._internal_maxhp());
  }
  if (from._internal_attack() != 0) {
    _this->_internal_set_attack(from._internal_attack());
  }
  if (from._internal_defence() != 0) {
    _this->_internal_set_defence(from._internal_defence());
  }
  if (from._internal_maxexp() != 0) {
    _this->_internal_set_maxexp(from._internal_maxexp());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void S_LevelUp::CopyFrom(const S_LevelUp& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:Protocol.S_LevelUp)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool S_LevelUp::IsInitialized() const {
  return true;
}

void S_LevelUp::InternalSwap(S_LevelUp* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(S_LevelUp, _impl_.maxexp_)
      + sizeof(S_LevelUp::_impl_.maxexp_)
      - PROTOBUF_FIELD_OFFSET(S_LevelUp, _impl_.playerid_)>(
          reinterpret_cast<char*>(&_impl_.playerid_),
          reinterpret_cast<char*>(&other->_impl_.playerid_));
}

::PROTOBUF_NAMESPACE_ID::Metadata S_LevelUp::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_Protocol_2eproto_getter, &descriptor_table_Protocol_2eproto_once,
      file_level_metadata_Protocol_2eproto[15]);
}

// ===================================================================

class S_InventoryData::_Internal {
 public:
  static const ::Protocol::ItemInfo& equippedweapon(const S_InventoryData* msg);
  static const ::Protocol::ItemInfo& equippedarmor(const S_InventoryData* msg);
  static const ::Protocol::ItemInfo& equippedpotion(const S_InventoryData* msg);
};

const ::Protocol::ItemInfo&
S_InventoryData::_Internal::equippedweapon(const S_InventoryData* msg) {
  return *msg->_impl_.equippedweapon_;
}
const ::Protocol::ItemInfo&
S_InventoryData::_Internal::equippedarmor(const S_InventoryData* msg) {
  return *msg->_impl_.equippedarmor_;
}
const ::Protocol::ItemInfo&
S_InventoryData::_Internal::equippedpotion(const S_InventoryData* msg) {
  return *msg->_impl_.equippedpotion_;
}
void S_InventoryData::clear_items() {
  _impl_.items_.Clear();
}
void S_InventoryData::clear_equippedweapon() {
  if (GetArenaForAllocation() == nullptr && _impl_.equippedweapon_ != nullptr) {
    delete _impl_.equippedweapon_;
  }
  _impl_.equippedweapon_ = nullptr;
}
void S_InventoryData::clear_equippedarmor() {
  if (GetArenaForAllocation() == nullptr && _impl_.equippedarmor_ != nullptr) {
    delete _impl_.equippedarmor_;
  }
  _impl_.equippedarmor_ = nullptr;
}
void S_InventoryData::clear_equippedpotion() {
  if (GetArenaForAllocation() == nullptr && _impl_.equippedpotion_ != nullptr) {
    delete _impl_.equippedpotion_;
  }
  _impl_.equippedpotion_ = nullptr;
}
S_InventoryData::S_InventoryData(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:Protocol.S_InventoryData)
}
S_InventoryData::S_InventoryData(const S_InventoryData& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  S_InventoryData* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.items_){from._impl_.items_}
    , decltype(_impl_.equippedweapon_){nullptr}
    , decltype(_impl_.equippedarmor_){nullptr}
    , decltype(_impl_.equippedpotion_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_equippedweapon()) {
    _this->_impl_.equippedweapon_ = new ::Protocol::ItemInfo(*from._impl_.equippedweapon_);
  }
  if (from._internal_has_equippedarmor()) {
    _this->_impl_.equippedarmor_ = new ::Protocol::ItemInfo(*from._impl_.equippedarmor_);
  }
  if (from._internal_has_equippedpotion()) {
    _this->_impl_.equippedpotion_ = new ::Protocol::ItemInfo(*from._impl_.equippedpotion_);
  }
  // @@protoc_insertion_point(copy_constructor:Protocol.S_InventoryData)
}

inline void S_InventoryData::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.items_){arena}
    , decltype(_impl_.equippedweapon_){nullptr}
    , decltype(_impl_.equippedarmor_){nullptr}
    , decltype(_impl_.equippedpotion_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

S_InventoryData::~S_InventoryData() {
  // @@protoc_insertion_point(destructor:Protocol.S_InventoryData)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void S_InventoryData::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.items_.~RepeatedPtrField();
  if (this != internal_default_instance()) delete _impl_.equippedweapon_;
  if (this != internal_default_instance()) delete _impl_.equippedarmor_;
  if (this != internal_default_instance()) delete _impl_.equippedpotion_;
}

void S_InventoryData::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void S_InventoryData::Clear() {
// @@protoc_insertion_point(message_clear_start:Protocol.S_InventoryData)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.items_.Clear();
  if (GetArenaForAllocation() == nullptr && _impl_.equippedweapon_ != nullptr) {
    delete _impl_.equippedweapon_;
  }
  _impl_.equippedweapon_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.equippedarmor_ != nullptr) {
    delete _impl_.equippedarmor_;
  }
  _impl_.equippedarmor_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.equippedpotion_ != nullptr) {
    delete _impl_.equippedpotion_;
  }
  _impl_.equippedpotion_ = nullptr;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* S_InventoryData::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .Protocol.ItemInfo items = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_items(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      // .Protocol.ItemInfo equippedWeapon = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_equippedweapon(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .Protocol.ItemInfo equippedArmor = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_equippedarmor(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .Protocol.ItemInfo equippedPotion = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_equippedpotion(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* S_InventoryData::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:Protocol.S_InventoryData)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .Protocol.ItemInfo items = 1;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_items_size()); i < n; i++) {
    const auto& repfield = this->_internal_items(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
  }

  // .Protocol.ItemInfo equippedWeapon = 2;
  if (this->_internal_has_equippedweapon()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::equippedweapon(this),
        _Internal::equippedweapon(this).GetCachedSize(), target, stream);
  }

  // .Protocol.ItemInfo equippedArmor = 3;
  if (this->_internal_has_equippedarmor()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::equippedarmor(this),
        _Internal::equippedarmor(this).GetCachedSize(), target, stream);
  }

  // .Protocol.ItemInfo equippedPotion = 4;
  if (this->_internal_has_equippedpotion()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(4, _Internal::equippedpotion(this),
        _Internal::equippedpotion(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:Protocol.S_InventoryData)
  return target;
}

size_t S_InventoryData::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:Protocol.S_InventoryData)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .Protocol.ItemInfo items = 1;
  total_size += 1UL * this->_internal_items_size();
  for (const auto& msg : this->_impl_.items_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // .Protocol.ItemInfo equippedWeapon = 2;
  if (this->_internal_has_equippedweapon()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.equippedweapon_);
  }

  // .Protocol.ItemInfo equippedArmor = 3;
  if (this->_internal_has_equippedarmor()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.equippedarmor_);
  }

  // .Protocol.ItemInfo equippedPotion = 4;
  if (this->_internal_has_equippedpotion()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.equippedpotion_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData S_InventoryData::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    S_InventoryData::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*S_InventoryData::GetClassData() const { return &_class_data_; }


void S_InventoryData::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<S_InventoryData*>(&to_msg);
  auto& from = static_cast<const S_InventoryData&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:Protocol.S_InventoryData)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.items_.MergeFrom(from._impl_.items_);
  if (from._internal_has_equippedweapon()) {
    _this->_internal_mutable_equippedweapon()->::Protocol::ItemInfo::MergeFrom(
        from._internal_equippedweapon());
  }
  if (from._internal_has_equippedarmor()) {
    _this->_internal_mutable_equippedarmor()->::Protocol::ItemInfo::MergeFrom(
        from._internal_equippedarmor());
  }
  if (from._internal_has_equippedpotion()) {
    _this->_internal_mutable_equippedpotion()->::Protocol::ItemInfo::MergeFrom(
        from._internal_equippedpotion());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void S_InventoryData::CopyFrom(const S_InventoryData& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:Protocol.S_InventoryData)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool S_InventoryData::IsInitialized() const {
  return true;
}

void S_InventoryData::InternalSwap(S_InventoryData* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.items_.InternalSwap(&other->_impl_.items_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(S_InventoryData, _impl_.equippedpotion_)
      + sizeof(S_InventoryData::_impl_.equippedpotion_)
      - PROTOBUF_FIELD_OFFSET(S_InventoryData, _impl_.equippedweapon_)>(
          reinterpret_cast<char*>(&_impl_.equippedweapon_),
          reinterpret_cast<char*>(&other->_impl_.equippedweapon_));
}

::PROTOBUF_NAMESPACE_ID::Metadata S_InventoryData::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_Protocol_2eproto_getter, &descriptor_table_Protocol_2eproto_once,
      file_level_metadata_Protocol_2eproto[16]);
}

// ===================================================================

class S_AddItem::_Internal {
 public:
};

S_AddItem::S_AddItem(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:Protocol.S_AddItem)
}
S_AddItem::S_AddItem(const S_AddItem& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  S_AddItem* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.itemid_){}
    , decltype(_impl_.slot_){}
    , decltype(_impl_.count_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.itemid_, &from._impl_.itemid_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.count_) -
    reinterpret_cast<char*>(&_impl_.itemid_)) + sizeof(_impl_.count_));
  // @@protoc_insertion_point(copy_constructor:Protocol.S_AddItem)
}

inline void S_AddItem::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.itemid_){0}
    , decltype(_impl_.slot_){0}
    , decltype(_impl_.count_){0}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

S_AddItem::~S_AddItem() {
  // @@protoc_insertion_point(destructor:Protocol.S_AddItem)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void S_AddItem::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void S_AddItem::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void S_AddItem::Clear() {
// @@protoc_insertion_point(message_clear_start:Protocol.S_AddItem)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::memset(&_impl_.itemid_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.count_) -
      reinterpret_cast<char*>(&_impl_.itemid_)) + sizeof(_impl_.count_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* S_AddItem::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // int32 itemId = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _impl_.itemid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // int32 slot = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _impl_.slot_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // int32 count = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _impl_.count_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* S_AddItem::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:Protocol.S_AddItem)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // int32 itemId = 1;
  if (this->_internal_itemid() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(1, this->_internal_itemid(), target);
  }

  // int32 slot = 2;
  if (this->_internal_slot() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(2, this->_internal_slot(), target);
  }

  // int32 count = 3;
  if (this->_internal_count() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(3, this->_internal_count(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:Protocol.S_AddItem)
  return target;
}

size_t S_AddItem::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:Protocol.S_AddItem)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // int32 itemId = 1;
  if (this->_internal_itemid() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_itemid());
  }

  // int32 slot = 2;
  if (this->_internal_slot() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_slot());
  }

  // int32 count = 3;
  if (this->_internal_count() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_count());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData S_AddItem::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    S_AddItem::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*S_AddItem::GetClassData() const { return &_class_data_; }


void S_AddItem::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<S_AddItem*>(&to_msg);
  auto& from = static_cast<const S_AddItem&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:Protocol.S_AddItem)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_itemid() != 0) {
    _this->_internal_set_itemid(from._internal_itemid());
  }
  if (from._internal_slot() != 0) {
    _this->_internal_set_slot(from._internal_slot());
  }
  if (from._internal_count() != 0) {
    _this->_internal_set_count(from._internal_count());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void S_AddItem::CopyFrom(const S_AddItem& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:Protocol.S_AddItem)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool S_AddItem::IsInitialized() const {
  return true;
}

void S_AddItem::InternalSwap(S_AddItem* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(S_AddItem, _impl_.count_)
      + sizeof(S_AddItem::_impl_.count_)
      - PROTOBUF_FIELD_OFFSET(S_AddItem, _impl_.itemid_)>(
          reinterpret_cast<char*>(&_impl_.itemid_),
          reinterpret_cast<char*>(&other->_impl_.itemid_));
}

::PROTOBUF_NAMESPACE_ID::Metadata S_AddItem::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_Protocol_2eproto_getter, &descriptor_table_Protocol_2eproto_once,
      file_level_metadata_Protocol_2eproto[17]);
}

// ===================================================================

class S_EquipItem::_Internal {
 public:
};

S_EquipItem::S_EquipItem(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:Protocol.S_EquipItem)
}
S_EquipItem::S_EquipItem(const S_EquipItem& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  S_EquipItem* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.equiptype_){}
    , decltype(_impl_.storageslot_){}
    , decltype(_impl_.storageitemid_){}
    , decltype(_impl_.storageitemcount_){}
    , decltype(_impl_.equipitemid_){}
    , decltype(_impl_.equipitemcount_){}
    , decltype(_impl_.attack_){}
    , decltype(_impl_.defence_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.equiptype_, &from._impl_.equiptype_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.defence_) -
    reinterpret_cast<char*>(&_impl_.equiptype_)) + sizeof(_impl_.defence_));
  // @@protoc_insertion_point(copy_constructor:Protocol.S_EquipItem)
}

inline void S_EquipItem::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.equiptype_){0}
    , decltype(_impl_.storageslot_){0}
    , decltype(_impl_.storageitemid_){0}
    , decltype(_impl_.storageitemcount_){0}
    , decltype(_impl_.equipitemid_){0}
    , decltype(_impl_.equipitemcount_){0}
    , decltype(_impl_.attack_){0}
    , decltype(_impl_.defence_){0}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

S_EquipItem::~S_EquipItem() {
  // @@protoc_insertion_point(destructor:Protocol.S_EquipItem)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void S_EquipItem::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void S_EquipItem::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void S_EquipItem::Clear() {
// @@protoc_insertion_point(message_clear_start:Protocol.S_EquipItem)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::memset(&_impl_.equiptype_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.defence_) -
      reinterpret_cast<char*>(&_impl_.equiptype_)) + sizeof(_impl_.defence_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* S_EquipItem::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // int32 equipType = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _impl_.equiptype_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // int32 storageSlot = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _impl_.storageslot_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // int32 storageItemId = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _impl_.storageitemid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // int32 storageItemCount = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _impl_.storageitemcount_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // int32 equipItemId = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _impl_.equipitemid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // int32 equipItemCount = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          _impl_.equipitemcount_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // int32 attack = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 56)) {
          _impl_.attack_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // int32 defence = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 64)) {
          _impl_.defence_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* S_EquipItem::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:Protocol.S_EquipItem)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // int32 equipType = 1;
  if (this->_internal_equiptype() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(1, this->_internal_equiptype(), target);
  }

  // int32 storageSlot = 2;
  if (this->_internal_storageslot() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(2, this->_internal_storageslot(), target);
  }

  // int32 storageItemId = 3;
  if (this->_internal_storageitemid() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(3, this->_internal_storageitemid(), target);
  }

  // int32 storageItemCount = 4;
  if (this->_internal_storageitemcount() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(4, this->_internal_storageitemcount(), target);
  }

  // int32 equipItemId = 5;
  if (this->_internal_equipitemid() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(5, this->_internal_equipitemid(), target);
  }

  // int32 equipItemCount = 6;
  if (this->_internal_equipitemcount() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(6, this->_internal_equipitemcount(), target);
  }

  // int32 attack = 7;
  if (this->_internal_attack() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(7, this->_internal_attack(), target);
  }

  // int32 defence = 8;
  if (this->_internal_defence() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(8, this->_internal_defence(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:Protocol.S_EquipItem)
  return target;
}

size_t S_EquipItem::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:Protocol.S_EquipItem)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // int32 equipType = 1;
  if (this->_internal_equiptype() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_equiptype());
  }

  // int32 storageSlot = 2;
  if (this->_internal_storageslot() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_storageslot());
  }

  // int32 storageItemId = 3;
  if (this->_internal_storageitemid() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_storageitemid());
  }

  // int32 storageItemCount = 4;
  if (this->_internal_storageitemcount() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_storageitemcount());
  }

  // int32 equipItemId = 5;
  if (this->_internal_equipitemid() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_equipitemid());
  }

  // int32 equipItemCount = 6;
  if (this->_internal_equipitemcount() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_equipitemcount());
  }

  // int32 attack = 7;
  if (this->_internal_attack() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_attack());
  }

  // int32 defence = 8;
  if (this->_internal_defence() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_defence());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData S_EquipItem::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    S_EquipItem::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*S_EquipItem::GetClassData() const { return &_class_data_; }


void S_EquipItem::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<S_EquipItem*>(&to_msg);
  auto& from = static_cast<const S_EquipItem&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:Protocol.S_EquipItem)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_equiptype() != 0) {
    _this->_internal_set_equiptype(from._internal_equiptype());
  }
  if (from._internal_storageslot() != 0) {
    _this->_internal_set_storageslot(from._internal_storageslot());
  }
  if (from._internal_storageitemid() != 0) {
    _this->_internal_set_storageitemid(from._internal_storageitemid());
  }
  if (from._internal_storageitemcount() != 0) {
    _this->_internal_set_storageitemcount(from._internal_storageitemcount());
  }
  if (from._internal_equipitemid() != 0) {
    _this->_internal_set_equipitemid(from._internal_equipitemid());
  }
  if (from._internal_equipitemcount() != 0) {
    _this->_internal_set_equipitemcount(from._internal_equipitemcount());
  }
  if (from._internal_attack() != 0) {
    _this->_internal_set_attack(from._internal_attack());
  }
  if (from._internal_defence() != 0) {
    _this->_internal_set_defence(from._internal_defence());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void S_EquipItem::CopyFrom(const S_EquipItem& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:Protocol.S_EquipItem)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool S_EquipItem::IsInitialized() const {
  return true;
}

void S_EquipItem::InternalSwap(S_EquipItem* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(S_EquipItem, _impl_.defence_)
      + sizeof(S_EquipItem::_impl_.defence_)
      - PROTOBUF_FIELD_OFFSET(S_EquipItem, _impl_.equiptype_)>(
          reinterpret_cast<char*>(&_impl_.equiptype_),
          reinterpret_cast<char*>(&other->_impl_.equiptype_));
}

::PROTOBUF_NAMESPACE_ID::Metadata S_EquipItem::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_Protocol_2eproto_getter, &descriptor_table_Protocol_2eproto_once,
      file_level_metadata_Protocol_2eproto[18]);
}

// ===================================================================

class S_UnequipItem::_Internal {
 public:
};

S_UnequipItem::S_UnequipItem(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:Protocol.S_UnequipItem)
}
S_UnequipItem::S_UnequipItem(const S_UnequipItem& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  S_UnequipItem* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.equiptype_){}
    , decltype(_impl_.storageslot_){}
    , decltype(_impl_.attack_){}
    , decltype(_impl_.defence_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.equiptype_, &from._impl_.equiptype_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.defence_) -
    reinterpret_cast<char*>(&_impl_.equiptype_)) + sizeof(_impl_.defence_));
  // @@protoc_insertion_point(copy_constructor:Protocol.S_UnequipItem)
}

inline void S_UnequipItem::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.equiptype_){0}
    , decltype(_impl_.storageslot_){0}
    , decltype(_impl_.attack_){0}
    , decltype(_impl_.defence_){0}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

S_UnequipItem::~S_UnequipItem() {
  // @@protoc_insertion_point(destructor:Protocol.S_UnequipItem)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void S_UnequipItem::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void S_UnequipItem::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void S_UnequipItem::Clear() {
// @@protoc_insertion_point(message_clear_start:Protocol.S_UnequipItem)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::memset(&_impl_.equiptype_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.defence_) -
      reinterpret_cast<char*>(&_impl_.equiptype_)) + sizeof(_impl_.defence_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* S_UnequipItem::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // int32 equipType = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _impl_.equiptype_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // int32 storageSlot = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _impl_.storageslot_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // int32 attack = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _impl_.attack_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // int32 defence = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _impl_.defence_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* S_UnequipItem::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:Protocol.S_UnequipItem)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // int32 equipType = 1;
  if (this->_internal_equiptype() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(1, this->_internal_equiptype(), target);
  }

  // int32 storageSlot = 2;
  if (this->_internal_storageslot() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(2, this->_internal_storageslot(), target);
  }

  // int32 attack = 3;
  if (this->_internal_attack() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(3, this->_internal_attack(), target);
  }

  // int32 defence = 4;
  if (this->_internal_defence() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(4, this->_internal_defence(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:Protocol.S_UnequipItem)
  return target;
}

size_t S_UnequipItem::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:Protocol.S_UnequipItem)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // int32 equipType = 1;
  if (this->_internal_equiptype() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_equiptype());
  }

  // int32 storageSlot = 2;
  if (this->_internal_storageslot() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_storageslot());
  }

  // int32 attack = 3;
  if (this->_internal_attack() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_attack());
  }

  // int32 defence = 4;
  if (this->_internal_defence() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_defence());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData S_UnequipItem::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    S_UnequipItem::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*S_UnequipItem::GetClassData() const { return &_class_data_; }


void S_UnequipItem::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<S_UnequipItem*>(&to_msg);
  auto& from = static_cast<const S_UnequipItem&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:Protocol.S_UnequipItem)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_equiptype() != 0) {
    _this->_internal_set_equiptype(from._internal_equiptype());
  }
  if (from._internal_storageslot() != 0) {
    _this->_internal_set_storageslot(from._internal_storageslot());
  }
  if (from._internal_attack() != 0) {
    _this->_internal_set_attack(from._internal_attack());
  }
  if (from._internal_defence() != 0) {
    _this->_internal_set_defence(from._internal_defence());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void S_UnequipItem::CopyFrom(const S_UnequipItem& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:Protocol.S_UnequipItem)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool S_UnequipItem::IsInitialized() const {
  return true;
}

void S_UnequipItem::InternalSwap(S_UnequipItem* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(S_UnequipItem, _impl_.defence_)
      + sizeof(S_UnequipItem::_impl_.defence_)
      - PROTOBUF_FIELD_OFFSET(S_UnequipItem, _impl_.equiptype_)>(
          reinterpret_cast<char*>(&_impl_.equiptype_),
          reinterpret_cast<char*>(&other->_impl_.equiptype_));
}

::PROTOBUF_NAMESPACE_ID::Metadata S_UnequipItem::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_Protocol_2eproto_getter, &descriptor_table_Protocol_2eproto_once,
      file_level_metadata_Protocol_2eproto[19]);
}

// ===================================================================

class S_UseItem::_Internal {
 public:
};

S_UseItem::S_UseItem(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:Protocol.S_UseItem)
}
S_UseItem::S_UseItem(const S_UseItem& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  S_UseItem* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.equiptype_){}
    , decltype(_impl_.remaincount_){}
    , decltype(_impl_.newhp_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.equiptype_, &from._impl_.equiptype_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.newhp_) -
    reinterpret_cast<char*>(&_impl_.equiptype_)) + sizeof(_impl_.newhp_));
  // @@protoc_insertion_point(copy_constructor:Protocol.S_UseItem)
}

inline void S_UseItem::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.equiptype_){0}
    , decltype(_impl_.remaincount_){0}
    , decltype(_impl_.newhp_){0}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

S_UseItem::~S_UseItem() {
  // @@protoc_insertion_point(destructor:Protocol.S_UseItem)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void S_UseItem::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void S_UseItem::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void S_UseItem::Clear() {
// @@protoc_insertion_point(message_clear_start:Protocol.S_UseItem)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::memset(&_impl_.equiptype_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.newhp_) -
      reinterpret_cast<char*>(&_impl_.equiptype_)) + sizeof(_impl_.newhp_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* S_UseItem::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // int32 equipType = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _impl_.equiptype_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // int32 remainCount = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _impl_.remaincount_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // int32 newHp = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _impl_.newhp_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* S_UseItem::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:Protocol.S_UseItem)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // int32 equipType = 1;
  if (this->_internal_equiptype() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(1, this->_internal_equiptype(), target);
  }

  // int32 remainCount = 2;
  if (this->_internal_remaincount() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(2, this->_internal_remaincount(), target);
  }

  // int32 newHp = 3;
  if (this->_internal_newhp() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(3, this->_internal_newhp(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:Protocol.S_UseItem)
  return target;
}

size_t S_UseItem::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:Protocol.S_UseItem)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // int32 equipType = 1;
  if (this->_internal_equiptype() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_equiptype());
  }

  // int32 remainCount = 2;
  if (this->_internal_remaincount() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_remaincount());
  }

  // int32 newHp = 3;
  if (this->_internal_newhp() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_newhp());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData S_UseItem::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    S_UseItem::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*S_UseItem::GetClassData() const { return &_class_data_; }


void S_UseItem::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<S_UseItem*>(&to_msg);
  auto& from = static_cast<const S_UseItem&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:Protocol.S_UseItem)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_equiptype() != 0) {
    _this->_internal_set_equiptype(from._internal_equiptype());
  }
  if (from._internal_remaincount() != 0) {
    _this->_internal_set_remaincount(from._internal_remaincount());
  }
  if (from._internal_newhp() != 0) {
    _this->_internal_set_newhp(from._internal_newhp());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void S_UseItem::CopyFrom(const S_UseItem& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:Protocol.S_UseItem)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool S_UseItem::IsInitialized() const {
  return true;
}

void S_UseItem::InternalSwap(S_UseItem* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(S_UseItem, _impl_.newhp_)
      + sizeof(S_UseItem::_impl_.newhp_)
      - PROTOBUF_FIELD_OFFSET(S_UseItem, _impl_.equiptype_)>(
          reinterpret_cast<char*>(&_impl_.equiptype_),
          reinterpret_cast<char*>(&other->_impl_.equiptype_));
}

::PROTOBUF_NAMESPACE_ID::Metadata S_UseItem::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_Protocol_2eproto_getter, &descriptor_table_Protocol_2eproto_once,
      file_level_metadata_Protocol_2eproto[20]);
}

// ===================================================================

class C_EquipItem::_Internal {
 public:
};

C_EquipItem::C_EquipItem(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:Protocol.C_EquipItem)
}
C_EquipItem::C_EquipItem(const C_EquipItem& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  C_EquipItem* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.slot_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _this->_impl_.slot_ = from._impl_.slot_;
  // @@protoc_insertion_point(copy_constructor:Protocol.C_EquipItem)
}

inline void C_EquipItem::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.slot_){0}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

C_EquipItem::~C_EquipItem() {
  // @@protoc_insertion_point(destructor:Protocol.C_EquipItem)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void C_EquipItem::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void C_EquipItem::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void C_EquipItem::Clear() {
// @@protoc_insertion_point(message_clear_start:Protocol.C_EquipItem)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.slot_ = 0;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* C_EquipItem::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // int32 slot = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _impl_.slot_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* C_EquipItem::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:Protocol.C_EquipItem)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // int32 slot = 1;
  if (this->_internal_slot() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(1, this->_internal_slot(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:Protocol.C_EquipItem)
  return target;
}

size_t C_EquipItem::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:Protocol.C_EquipItem)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // int32 slot = 1;
  if (this->_internal_slot() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_slot());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData C_EquipItem::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    C_EquipItem::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*C_EquipItem::GetClassData() const { return &_class_data_; }


void C_EquipItem::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<C_EquipItem*>(&to_msg);
  auto& from = static_cast<const C_EquipItem&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:Protocol.C_EquipItem)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_slot() != 0) {
    _this->_internal_set_slot(from._internal_slot());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void C_EquipItem::CopyFrom(const C_EquipItem& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:Protocol.C_EquipItem)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool C_EquipItem::IsInitialized() const {
  return true;
}

void C_EquipItem::InternalSwap(C_EquipItem* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_.slot_, other->_impl_.slot_);
}

::PROTOBUF_NAMESPACE_ID::Metadata C_EquipItem::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_Protocol_2eproto_getter, &descriptor_table_Protocol_2eproto_once,
      file_level_metadata_Protocol_2eproto[21]);
}

// ===================================================================

class C_UnequipItem::_Internal {
 public:
};

C_UnequipItem::C_UnequipItem(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:Protocol.C_UnequipItem)
}
C_UnequipItem::C_UnequipItem(const C_UnequipItem& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  C_UnequipItem* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.equiptype_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _this->_impl_.equiptype_ = from._impl_.equiptype_;
  // @@protoc_insertion_point(copy_constructor:Protocol.C_UnequipItem)
}

inline void C_UnequipItem::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.equiptype_){0}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

C_UnequipItem::~C_UnequipItem() {
  // @@protoc_insertion_point(destructor:Protocol.C_UnequipItem)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void C_UnequipItem::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void C_UnequipItem::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void C_UnequipItem::Clear() {
// @@protoc_insertion_point(message_clear_start:Protocol.C_UnequipItem)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.equiptype_ = 0;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* C_UnequipItem::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // int32 equipType = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _impl_.equiptype_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* C_UnequipItem::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:Protocol.C_UnequipItem)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // int32 equipType = 1;
  if (this->_internal_equiptype() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(1, this->_internal_equiptype(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:Protocol.C_UnequipItem)
  return target;
}

size_t C_UnequipItem::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:Protocol.C_UnequipItem)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // int32 equipType = 1;
  if (this->_internal_equiptype() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_equiptype());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData C_UnequipItem::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    C_UnequipItem::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*C_UnequipItem::GetClassData() const { return &_class_data_; }


void C_UnequipItem::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<C_UnequipItem*>(&to_msg);
  auto& from = static_cast<const C_UnequipItem&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:Protocol.C_UnequipItem)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_equiptype() != 0) {
    _this->_internal_set_equiptype(from._internal_equiptype());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void C_UnequipItem::CopyFrom(const C_UnequipItem& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:Protocol.C_UnequipItem)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool C_UnequipItem::IsInitialized() const {
  return true;
}

void C_UnequipItem::InternalSwap(C_UnequipItem* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_.equiptype_, other->_impl_.equiptype_);
}

::PROTOBUF_NAMESPACE_ID::Metadata C_UnequipItem::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_Protocol_2eproto_getter, &descriptor_table_Protocol_2eproto_once,
      file_level_metadata_Protocol_2eproto[22]);
}

// ===================================================================

class C_UseItem::_Internal {
 public:
};

C_UseItem::C_UseItem(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:Protocol.C_UseItem)
}
C_UseItem::C_UseItem(const C_UseItem& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  C_UseItem* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.slot_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _this->_impl_.slot_ = from._impl_.slot_;
  // @@protoc_insertion_point(copy_constructor:Protocol.C_UseItem)
}

inline void C_UseItem::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.slot_){0}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

C_UseItem::~C_UseItem() {
  // @@protoc_insertion_point(destructor:Protocol.C_UseItem)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void C_UseItem::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void C_UseItem::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void C_UseItem::Clear() {
// @@protoc_insertion_point(message_clear_start:Protocol.C_UseItem)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.slot_ = 0;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* C_UseItem::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // int32 slot = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _impl_.slot_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* C_UseItem::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:Protocol.C_UseItem)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // int32 slot = 1;
  if (this->_internal_slot() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(1, this->_internal_slot(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:Protocol.C_UseItem)
  return target;
}

size_t C_UseItem::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:Protocol.C_UseItem)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // int32 slot = 1;
  if (this->_internal_slot() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_slot());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData C_UseItem::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    C_UseItem::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*C_UseItem::GetClassData() const { return &_class_data_; }


void C_UseItem::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<C_UseItem*>(&to_msg);
  auto& from = static_cast<const C_UseItem&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:Protocol.C_UseItem)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_slot() != 0) {
    _this->_internal_set_slot(from._internal_slot());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void C_UseItem::CopyFrom(const C_UseItem& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:Protocol.C_UseItem)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool C_UseItem::IsInitialized() const {
  return true;
}

void C_UseItem::InternalSwap(C_UseItem* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_.slot_, other->_impl_.slot_);
}

::PROTOBUF_NAMESPACE_ID::Metadata C_UseItem::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_Protocol_2eproto_getter, &descriptor_table_Protocol_2eproto_once,
      file_level_metadata_Protocol_2eproto[23]);
}

// @@protoc_insertion_point(namespace_scope)
}  // namespace Protocol
PROTOBUF_NAMESPACE_OPEN
template<> PROTOBUF_NOINLINE ::Protocol::S_TEST*
Arena::CreateMaybeMessage< ::Protocol::S_TEST >(Arena* arena) {
  return Arena::CreateMessageInternal< ::Protocol::S_TEST >(arena);
}
template<> PROTOBUF_NOINLINE ::Protocol::S_EnterGame*
Arena::CreateMaybeMessage< ::Protocol::S_EnterGame >(Arena* arena) {
  return Arena::CreateMessageInternal< ::Protocol::S_EnterGame >(arena);
}
template<> PROTOBUF_NOINLINE ::Protocol::S_MyPlayer*
Arena::CreateMaybeMessage< ::Protocol::S_MyPlayer >(Arena* arena) {
  return Arena::CreateMessageInternal< ::Protocol::S_MyPlayer >(arena);
}
template<> PROTOBUF_NOINLINE ::Protocol::S_AddObject*
Arena::CreateMaybeMessage< ::Protocol::S_AddObject >(Arena* arena) {
  return Arena::CreateMessageInternal< ::Protocol::S_AddObject >(arena);
}
template<> PROTOBUF_NOINLINE ::Protocol::S_RemoveObject*
Arena::CreateMaybeMessage< ::Protocol::S_RemoveObject >(Arena* arena) {
  return Arena::CreateMessageInternal< ::Protocol::S_RemoveObject >(arena);
}
template<> PROTOBUF_NOINLINE ::Protocol::C_Move*
Arena::CreateMaybeMessage< ::Protocol::C_Move >(Arena* arena) {
  return Arena::CreateMessageInternal< ::Protocol::C_Move >(arena);
}
template<> PROTOBUF_NOINLINE ::Protocol::S_Move*
Arena::CreateMaybeMessage< ::Protocol::S_Move >(Arena* arena) {
  return Arena::CreateMessageInternal< ::Protocol::S_Move >(arena);
}
template<> PROTOBUF_NOINLINE ::Protocol::C_Turn*
Arena::CreateMaybeMessage< ::Protocol::C_Turn >(Arena* arena) {
  return Arena::CreateMessageInternal< ::Protocol::C_Turn >(arena);
}
template<> PROTOBUF_NOINLINE ::Protocol::S_Turn*
Arena::CreateMaybeMessage< ::Protocol::S_Turn >(Arena* arena) {
  return Arena::CreateMessageInternal< ::Protocol::S_Turn >(arena);
}
template<> PROTOBUF_NOINLINE ::Protocol::C_Attack*
Arena::CreateMaybeMessage< ::Protocol::C_Attack >(Arena* arena) {
  return Arena::CreateMessageInternal< ::Protocol::C_Attack >(arena);
}
template<> PROTOBUF_NOINLINE ::Protocol::S_Attack*
Arena::CreateMaybeMessage< ::Protocol::S_Attack >(Arena* arena) {
  return Arena::CreateMessageInternal< ::Protocol::S_Attack >(arena);
}
template<> PROTOBUF_NOINLINE ::Protocol::S_Damaged*
Arena::CreateMaybeMessage< ::Protocol::S_Damaged >(Arena* arena) {
  return Arena::CreateMessageInternal< ::Protocol::S_Damaged >(arena);
}
template<> PROTOBUF_NOINLINE ::Protocol::C_ChangeMap*
Arena::CreateMaybeMessage< ::Protocol::C_ChangeMap >(Arena* arena) {
  return Arena::CreateMessageInternal< ::Protocol::C_ChangeMap >(arena);
}
template<> PROTOBUF_NOINLINE ::Protocol::S_ChangeMap*
Arena::CreateMaybeMessage< ::Protocol::S_ChangeMap >(Arena* arena) {
  return Arena::CreateMessageInternal< ::Protocol::S_ChangeMap >(arena);
}
template<> PROTOBUF_NOINLINE ::Protocol::S_GainExp*
Arena::CreateMaybeMessage< ::Protocol::S_GainExp >(Arena* arena) {
  return Arena::CreateMessageInternal< ::Protocol::S_GainExp >(arena);
}
template<> PROTOBUF_NOINLINE ::Protocol::S_LevelUp*
Arena::CreateMaybeMessage< ::Protocol::S_LevelUp >(Arena* arena) {
  return Arena::CreateMessageInternal< ::Protocol::S_LevelUp >(arena);
}
template<> PROTOBUF_NOINLINE ::Protocol::S_InventoryData*
Arena::CreateMaybeMessage< ::Protocol::S_InventoryData >(Arena* arena) {
  return Arena::CreateMessageInternal< ::Protocol::S_InventoryData >(arena);
}
template<> PROTOBUF_NOINLINE ::Protocol::S_AddItem*
Arena::CreateMaybeMessage< ::Protocol::S_AddItem >(Arena* arena) {
  return Arena::CreateMessageInternal< ::Protocol::S_AddItem >(arena);
}
template<> PROTOBUF_NOINLINE ::Protocol::S_EquipItem*
Arena::CreateMaybeMessage< ::Protocol::S_EquipItem >(Arena* arena) {
  return Arena::CreateMessageInternal< ::Protocol::S_EquipItem >(arena);
}
template<> PROTOBUF_NOINLINE ::Protocol::S_UnequipItem*
Arena::CreateMaybeMessage< ::Protocol::S_UnequipItem >(Arena* arena) {
  return Arena::CreateMessageInternal< ::Protocol::S_UnequipItem >(arena);
}
template<> PROTOBUF_NOINLINE ::Protocol::S_UseItem*
Arena::CreateMaybeMessage< ::Protocol::S_UseItem >(Arena* arena) {
  return Arena::CreateMessageInternal< ::Protocol::S_UseItem >(arena);
}
template<> PROTOBUF_NOINLINE ::Protocol::C_EquipItem*
Arena::CreateMaybeMessage< ::Protocol::C_EquipItem >(Arena* arena) {
  return Arena::CreateMessageInternal< ::Protocol::C_EquipItem >(arena);
}
template<> PROTOBUF_NOINLINE ::Protocol::C_UnequipItem*
Arena::CreateMaybeMessage< ::Protocol::C_UnequipItem >(Arena* arena) {
  return Arena::CreateMessageInternal< ::Protocol::C_UnequipItem >(arena);
}
template<> PROTOBUF_NOINLINE ::Protocol::C_UseItem*
Arena::CreateMaybeMessage< ::Protocol::C_UseItem >(Arena* arena) {
  return Arena::CreateMessageInternal< ::Protocol::C_UseItem >(arena);
}
PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)
#include <google/protobuf/port_undef.inc>
