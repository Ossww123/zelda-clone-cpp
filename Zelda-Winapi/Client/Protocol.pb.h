// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: Protocol.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_Protocol_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_Protocol_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021012 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_bases.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
#include "Enum.pb.h"
#include "Struct.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_Protocol_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_Protocol_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_Protocol_2eproto;
namespace Protocol {
class C_Attack;
struct C_AttackDefaultTypeInternal;
extern C_AttackDefaultTypeInternal _C_Attack_default_instance_;
class C_ChangeMap;
struct C_ChangeMapDefaultTypeInternal;
extern C_ChangeMapDefaultTypeInternal _C_ChangeMap_default_instance_;
class C_EquipItem;
struct C_EquipItemDefaultTypeInternal;
extern C_EquipItemDefaultTypeInternal _C_EquipItem_default_instance_;
class C_Login;
struct C_LoginDefaultTypeInternal;
extern C_LoginDefaultTypeInternal _C_Login_default_instance_;
class C_Move;
struct C_MoveDefaultTypeInternal;
extern C_MoveDefaultTypeInternal _C_Move_default_instance_;
class C_PartyAnswer;
struct C_PartyAnswerDefaultTypeInternal;
extern C_PartyAnswerDefaultTypeInternal _C_PartyAnswer_default_instance_;
class C_PartyInvite;
struct C_PartyInviteDefaultTypeInternal;
extern C_PartyInviteDefaultTypeInternal _C_PartyInvite_default_instance_;
class C_PartyLeave;
struct C_PartyLeaveDefaultTypeInternal;
extern C_PartyLeaveDefaultTypeInternal _C_PartyLeave_default_instance_;
class C_Turn;
struct C_TurnDefaultTypeInternal;
extern C_TurnDefaultTypeInternal _C_Turn_default_instance_;
class C_UnequipItem;
struct C_UnequipItemDefaultTypeInternal;
extern C_UnequipItemDefaultTypeInternal _C_UnequipItem_default_instance_;
class C_UseItem;
struct C_UseItemDefaultTypeInternal;
extern C_UseItemDefaultTypeInternal _C_UseItem_default_instance_;
class S_AddItem;
struct S_AddItemDefaultTypeInternal;
extern S_AddItemDefaultTypeInternal _S_AddItem_default_instance_;
class S_AddObject;
struct S_AddObjectDefaultTypeInternal;
extern S_AddObjectDefaultTypeInternal _S_AddObject_default_instance_;
class S_Attack;
struct S_AttackDefaultTypeInternal;
extern S_AttackDefaultTypeInternal _S_Attack_default_instance_;
class S_ChangeMap;
struct S_ChangeMapDefaultTypeInternal;
extern S_ChangeMapDefaultTypeInternal _S_ChangeMap_default_instance_;
class S_Damaged;
struct S_DamagedDefaultTypeInternal;
extern S_DamagedDefaultTypeInternal _S_Damaged_default_instance_;
class S_EnterGame;
struct S_EnterGameDefaultTypeInternal;
extern S_EnterGameDefaultTypeInternal _S_EnterGame_default_instance_;
class S_EquipItem;
struct S_EquipItemDefaultTypeInternal;
extern S_EquipItemDefaultTypeInternal _S_EquipItem_default_instance_;
class S_GainExp;
struct S_GainExpDefaultTypeInternal;
extern S_GainExpDefaultTypeInternal _S_GainExp_default_instance_;
class S_InventoryData;
struct S_InventoryDataDefaultTypeInternal;
extern S_InventoryDataDefaultTypeInternal _S_InventoryData_default_instance_;
class S_LevelUp;
struct S_LevelUpDefaultTypeInternal;
extern S_LevelUpDefaultTypeInternal _S_LevelUp_default_instance_;
class S_Move;
struct S_MoveDefaultTypeInternal;
extern S_MoveDefaultTypeInternal _S_Move_default_instance_;
class S_MyPlayer;
struct S_MyPlayerDefaultTypeInternal;
extern S_MyPlayerDefaultTypeInternal _S_MyPlayer_default_instance_;
class S_PartyInvite;
struct S_PartyInviteDefaultTypeInternal;
extern S_PartyInviteDefaultTypeInternal _S_PartyInvite_default_instance_;
class S_PartyLeave;
struct S_PartyLeaveDefaultTypeInternal;
extern S_PartyLeaveDefaultTypeInternal _S_PartyLeave_default_instance_;
class S_PartyUpdate;
struct S_PartyUpdateDefaultTypeInternal;
extern S_PartyUpdateDefaultTypeInternal _S_PartyUpdate_default_instance_;
class S_RemoveObject;
struct S_RemoveObjectDefaultTypeInternal;
extern S_RemoveObjectDefaultTypeInternal _S_RemoveObject_default_instance_;
class S_TEST;
struct S_TESTDefaultTypeInternal;
extern S_TESTDefaultTypeInternal _S_TEST_default_instance_;
class S_Turn;
struct S_TurnDefaultTypeInternal;
extern S_TurnDefaultTypeInternal _S_Turn_default_instance_;
class S_UnequipItem;
struct S_UnequipItemDefaultTypeInternal;
extern S_UnequipItemDefaultTypeInternal _S_UnequipItem_default_instance_;
class S_UseItem;
struct S_UseItemDefaultTypeInternal;
extern S_UseItemDefaultTypeInternal _S_UseItem_default_instance_;
}  // namespace Protocol
PROTOBUF_NAMESPACE_OPEN
template<> ::Protocol::C_Attack* Arena::CreateMaybeMessage<::Protocol::C_Attack>(Arena*);
template<> ::Protocol::C_ChangeMap* Arena::CreateMaybeMessage<::Protocol::C_ChangeMap>(Arena*);
template<> ::Protocol::C_EquipItem* Arena::CreateMaybeMessage<::Protocol::C_EquipItem>(Arena*);
template<> ::Protocol::C_Login* Arena::CreateMaybeMessage<::Protocol::C_Login>(Arena*);
template<> ::Protocol::C_Move* Arena::CreateMaybeMessage<::Protocol::C_Move>(Arena*);
template<> ::Protocol::C_PartyAnswer* Arena::CreateMaybeMessage<::Protocol::C_PartyAnswer>(Arena*);
template<> ::Protocol::C_PartyInvite* Arena::CreateMaybeMessage<::Protocol::C_PartyInvite>(Arena*);
template<> ::Protocol::C_PartyLeave* Arena::CreateMaybeMessage<::Protocol::C_PartyLeave>(Arena*);
template<> ::Protocol::C_Turn* Arena::CreateMaybeMessage<::Protocol::C_Turn>(Arena*);
template<> ::Protocol::C_UnequipItem* Arena::CreateMaybeMessage<::Protocol::C_UnequipItem>(Arena*);
template<> ::Protocol::C_UseItem* Arena::CreateMaybeMessage<::Protocol::C_UseItem>(Arena*);
template<> ::Protocol::S_AddItem* Arena::CreateMaybeMessage<::Protocol::S_AddItem>(Arena*);
template<> ::Protocol::S_AddObject* Arena::CreateMaybeMessage<::Protocol::S_AddObject>(Arena*);
template<> ::Protocol::S_Attack* Arena::CreateMaybeMessage<::Protocol::S_Attack>(Arena*);
template<> ::Protocol::S_ChangeMap* Arena::CreateMaybeMessage<::Protocol::S_ChangeMap>(Arena*);
template<> ::Protocol::S_Damaged* Arena::CreateMaybeMessage<::Protocol::S_Damaged>(Arena*);
template<> ::Protocol::S_EnterGame* Arena::CreateMaybeMessage<::Protocol::S_EnterGame>(Arena*);
template<> ::Protocol::S_EquipItem* Arena::CreateMaybeMessage<::Protocol::S_EquipItem>(Arena*);
template<> ::Protocol::S_GainExp* Arena::CreateMaybeMessage<::Protocol::S_GainExp>(Arena*);
template<> ::Protocol::S_InventoryData* Arena::CreateMaybeMessage<::Protocol::S_InventoryData>(Arena*);
template<> ::Protocol::S_LevelUp* Arena::CreateMaybeMessage<::Protocol::S_LevelUp>(Arena*);
template<> ::Protocol::S_Move* Arena::CreateMaybeMessage<::Protocol::S_Move>(Arena*);
template<> ::Protocol::S_MyPlayer* Arena::CreateMaybeMessage<::Protocol::S_MyPlayer>(Arena*);
template<> ::Protocol::S_PartyInvite* Arena::CreateMaybeMessage<::Protocol::S_PartyInvite>(Arena*);
template<> ::Protocol::S_PartyLeave* Arena::CreateMaybeMessage<::Protocol::S_PartyLeave>(Arena*);
template<> ::Protocol::S_PartyUpdate* Arena::CreateMaybeMessage<::Protocol::S_PartyUpdate>(Arena*);
template<> ::Protocol::S_RemoveObject* Arena::CreateMaybeMessage<::Protocol::S_RemoveObject>(Arena*);
template<> ::Protocol::S_TEST* Arena::CreateMaybeMessage<::Protocol::S_TEST>(Arena*);
template<> ::Protocol::S_Turn* Arena::CreateMaybeMessage<::Protocol::S_Turn>(Arena*);
template<> ::Protocol::S_UnequipItem* Arena::CreateMaybeMessage<::Protocol::S_UnequipItem>(Arena*);
template<> ::Protocol::S_UseItem* Arena::CreateMaybeMessage<::Protocol::S_UseItem>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace Protocol {

// ===================================================================

class S_TEST final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.S_TEST) */ {
 public:
  inline S_TEST() : S_TEST(nullptr) {}
  ~S_TEST() override;
  explicit PROTOBUF_CONSTEXPR S_TEST(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  S_TEST(const S_TEST& from);
  S_TEST(S_TEST&& from) noexcept
    : S_TEST() {
    *this = ::std::move(from);
  }

  inline S_TEST& operator=(const S_TEST& from) {
    CopyFrom(from);
    return *this;
  }
  inline S_TEST& operator=(S_TEST&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const S_TEST& default_instance() {
    return *internal_default_instance();
  }
  static inline const S_TEST* internal_default_instance() {
    return reinterpret_cast<const S_TEST*>(
               &_S_TEST_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(S_TEST& a, S_TEST& b) {
    a.Swap(&b);
  }
  inline void Swap(S_TEST* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(S_TEST* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  S_TEST* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<S_TEST>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const S_TEST& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const S_TEST& from) {
    S_TEST::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(S_TEST* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.S_TEST";
  }
  protected:
  explicit S_TEST(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBuffsFieldNumber = 4,
    kIdFieldNumber = 1,
    kHpFieldNumber = 2,
    kAttackFieldNumber = 3,
  };
  // repeated .Protocol.BuffData buffs = 4;
  int buffs_size() const;
  private:
  int _internal_buffs_size() const;
  public:
  void clear_buffs();
  ::Protocol::BuffData* mutable_buffs(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Protocol::BuffData >*
      mutable_buffs();
  private:
  const ::Protocol::BuffData& _internal_buffs(int index) const;
  ::Protocol::BuffData* _internal_add_buffs();
  public:
  const ::Protocol::BuffData& buffs(int index) const;
  ::Protocol::BuffData* add_buffs();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Protocol::BuffData >&
      buffs() const;

  // uint64 id = 1;
  void clear_id();
  uint64_t id() const;
  void set_id(uint64_t value);
  private:
  uint64_t _internal_id() const;
  void _internal_set_id(uint64_t value);
  public:

  // uint32 hp = 2;
  void clear_hp();
  uint32_t hp() const;
  void set_hp(uint32_t value);
  private:
  uint32_t _internal_hp() const;
  void _internal_set_hp(uint32_t value);
  public:

  // uint32 attack = 3;
  void clear_attack();
  uint32_t attack() const;
  void set_attack(uint32_t value);
  private:
  uint32_t _internal_attack() const;
  void _internal_set_attack(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:Protocol.S_TEST)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Protocol::BuffData > buffs_;
    uint64_t id_;
    uint32_t hp_;
    uint32_t attack_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class S_EnterGame final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.S_EnterGame) */ {
 public:
  inline S_EnterGame() : S_EnterGame(nullptr) {}
  ~S_EnterGame() override;
  explicit PROTOBUF_CONSTEXPR S_EnterGame(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  S_EnterGame(const S_EnterGame& from);
  S_EnterGame(S_EnterGame&& from) noexcept
    : S_EnterGame() {
    *this = ::std::move(from);
  }

  inline S_EnterGame& operator=(const S_EnterGame& from) {
    CopyFrom(from);
    return *this;
  }
  inline S_EnterGame& operator=(S_EnterGame&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const S_EnterGame& default_instance() {
    return *internal_default_instance();
  }
  static inline const S_EnterGame* internal_default_instance() {
    return reinterpret_cast<const S_EnterGame*>(
               &_S_EnterGame_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(S_EnterGame& a, S_EnterGame& b) {
    a.Swap(&b);
  }
  inline void Swap(S_EnterGame* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(S_EnterGame* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  S_EnterGame* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<S_EnterGame>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const S_EnterGame& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const S_EnterGame& from) {
    S_EnterGame::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(S_EnterGame* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.S_EnterGame";
  }
  protected:
  explicit S_EnterGame(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAccountIdFieldNumber = 2,
    kSuccessFieldNumber = 1,
  };
  // uint64 accountId = 2;
  void clear_accountid();
  uint64_t accountid() const;
  void set_accountid(uint64_t value);
  private:
  uint64_t _internal_accountid() const;
  void _internal_set_accountid(uint64_t value);
  public:

  // bool success = 1;
  void clear_success();
  bool success() const;
  void set_success(bool value);
  private:
  bool _internal_success() const;
  void _internal_set_success(bool value);
  public:

  // @@protoc_insertion_point(class_scope:Protocol.S_EnterGame)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    uint64_t accountid_;
    bool success_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class S_MyPlayer final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.S_MyPlayer) */ {
 public:
  inline S_MyPlayer() : S_MyPlayer(nullptr) {}
  ~S_MyPlayer() override;
  explicit PROTOBUF_CONSTEXPR S_MyPlayer(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  S_MyPlayer(const S_MyPlayer& from);
  S_MyPlayer(S_MyPlayer&& from) noexcept
    : S_MyPlayer() {
    *this = ::std::move(from);
  }

  inline S_MyPlayer& operator=(const S_MyPlayer& from) {
    CopyFrom(from);
    return *this;
  }
  inline S_MyPlayer& operator=(S_MyPlayer&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const S_MyPlayer& default_instance() {
    return *internal_default_instance();
  }
  static inline const S_MyPlayer* internal_default_instance() {
    return reinterpret_cast<const S_MyPlayer*>(
               &_S_MyPlayer_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(S_MyPlayer& a, S_MyPlayer& b) {
    a.Swap(&b);
  }
  inline void Swap(S_MyPlayer* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(S_MyPlayer* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  S_MyPlayer* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<S_MyPlayer>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const S_MyPlayer& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const S_MyPlayer& from) {
    S_MyPlayer::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(S_MyPlayer* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.S_MyPlayer";
  }
  protected:
  explicit S_MyPlayer(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kInfoFieldNumber = 1,
  };
  // .Protocol.ObjectInfo info = 1;
  bool has_info() const;
  private:
  bool _internal_has_info() const;
  public:
  void clear_info();
  const ::Protocol::ObjectInfo& info() const;
  PROTOBUF_NODISCARD ::Protocol::ObjectInfo* release_info();
  ::Protocol::ObjectInfo* mutable_info();
  void set_allocated_info(::Protocol::ObjectInfo* info);
  private:
  const ::Protocol::ObjectInfo& _internal_info() const;
  ::Protocol::ObjectInfo* _internal_mutable_info();
  public:
  void unsafe_arena_set_allocated_info(
      ::Protocol::ObjectInfo* info);
  ::Protocol::ObjectInfo* unsafe_arena_release_info();

  // @@protoc_insertion_point(class_scope:Protocol.S_MyPlayer)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::Protocol::ObjectInfo* info_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class S_AddObject final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.S_AddObject) */ {
 public:
  inline S_AddObject() : S_AddObject(nullptr) {}
  ~S_AddObject() override;
  explicit PROTOBUF_CONSTEXPR S_AddObject(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  S_AddObject(const S_AddObject& from);
  S_AddObject(S_AddObject&& from) noexcept
    : S_AddObject() {
    *this = ::std::move(from);
  }

  inline S_AddObject& operator=(const S_AddObject& from) {
    CopyFrom(from);
    return *this;
  }
  inline S_AddObject& operator=(S_AddObject&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const S_AddObject& default_instance() {
    return *internal_default_instance();
  }
  static inline const S_AddObject* internal_default_instance() {
    return reinterpret_cast<const S_AddObject*>(
               &_S_AddObject_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(S_AddObject& a, S_AddObject& b) {
    a.Swap(&b);
  }
  inline void Swap(S_AddObject* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(S_AddObject* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  S_AddObject* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<S_AddObject>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const S_AddObject& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const S_AddObject& from) {
    S_AddObject::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(S_AddObject* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.S_AddObject";
  }
  protected:
  explicit S_AddObject(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kObjectsFieldNumber = 1,
  };
  // repeated .Protocol.ObjectInfo objects = 1;
  int objects_size() const;
  private:
  int _internal_objects_size() const;
  public:
  void clear_objects();
  ::Protocol::ObjectInfo* mutable_objects(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Protocol::ObjectInfo >*
      mutable_objects();
  private:
  const ::Protocol::ObjectInfo& _internal_objects(int index) const;
  ::Protocol::ObjectInfo* _internal_add_objects();
  public:
  const ::Protocol::ObjectInfo& objects(int index) const;
  ::Protocol::ObjectInfo* add_objects();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Protocol::ObjectInfo >&
      objects() const;

  // @@protoc_insertion_point(class_scope:Protocol.S_AddObject)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Protocol::ObjectInfo > objects_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class S_RemoveObject final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.S_RemoveObject) */ {
 public:
  inline S_RemoveObject() : S_RemoveObject(nullptr) {}
  ~S_RemoveObject() override;
  explicit PROTOBUF_CONSTEXPR S_RemoveObject(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  S_RemoveObject(const S_RemoveObject& from);
  S_RemoveObject(S_RemoveObject&& from) noexcept
    : S_RemoveObject() {
    *this = ::std::move(from);
  }

  inline S_RemoveObject& operator=(const S_RemoveObject& from) {
    CopyFrom(from);
    return *this;
  }
  inline S_RemoveObject& operator=(S_RemoveObject&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const S_RemoveObject& default_instance() {
    return *internal_default_instance();
  }
  static inline const S_RemoveObject* internal_default_instance() {
    return reinterpret_cast<const S_RemoveObject*>(
               &_S_RemoveObject_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(S_RemoveObject& a, S_RemoveObject& b) {
    a.Swap(&b);
  }
  inline void Swap(S_RemoveObject* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(S_RemoveObject* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  S_RemoveObject* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<S_RemoveObject>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const S_RemoveObject& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const S_RemoveObject& from) {
    S_RemoveObject::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(S_RemoveObject* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.S_RemoveObject";
  }
  protected:
  explicit S_RemoveObject(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdsFieldNumber = 1,
  };
  // repeated uint64 ids = 1;
  int ids_size() const;
  private:
  int _internal_ids_size() const;
  public:
  void clear_ids();
  private:
  uint64_t _internal_ids(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
      _internal_ids() const;
  void _internal_add_ids(uint64_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
      _internal_mutable_ids();
  public:
  uint64_t ids(int index) const;
  void set_ids(int index, uint64_t value);
  void add_ids(uint64_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
      ids() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
      mutable_ids();

  // @@protoc_insertion_point(class_scope:Protocol.S_RemoveObject)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t > ids_;
    mutable std::atomic<int> _ids_cached_byte_size_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class C_Move final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.C_Move) */ {
 public:
  inline C_Move() : C_Move(nullptr) {}
  ~C_Move() override;
  explicit PROTOBUF_CONSTEXPR C_Move(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  C_Move(const C_Move& from);
  C_Move(C_Move&& from) noexcept
    : C_Move() {
    *this = ::std::move(from);
  }

  inline C_Move& operator=(const C_Move& from) {
    CopyFrom(from);
    return *this;
  }
  inline C_Move& operator=(C_Move&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const C_Move& default_instance() {
    return *internal_default_instance();
  }
  static inline const C_Move* internal_default_instance() {
    return reinterpret_cast<const C_Move*>(
               &_C_Move_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(C_Move& a, C_Move& b) {
    a.Swap(&b);
  }
  inline void Swap(C_Move* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(C_Move* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  C_Move* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<C_Move>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const C_Move& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const C_Move& from) {
    C_Move::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(C_Move* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.C_Move";
  }
  protected:
  explicit C_Move(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDirFieldNumber = 1,
  };
  // .Protocol.DIR_TYPE dir = 1;
  void clear_dir();
  ::Protocol::DIR_TYPE dir() const;
  void set_dir(::Protocol::DIR_TYPE value);
  private:
  ::Protocol::DIR_TYPE _internal_dir() const;
  void _internal_set_dir(::Protocol::DIR_TYPE value);
  public:

  // @@protoc_insertion_point(class_scope:Protocol.C_Move)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int dir_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class S_Move final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.S_Move) */ {
 public:
  inline S_Move() : S_Move(nullptr) {}
  ~S_Move() override;
  explicit PROTOBUF_CONSTEXPR S_Move(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  S_Move(const S_Move& from);
  S_Move(S_Move&& from) noexcept
    : S_Move() {
    *this = ::std::move(from);
  }

  inline S_Move& operator=(const S_Move& from) {
    CopyFrom(from);
    return *this;
  }
  inline S_Move& operator=(S_Move&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const S_Move& default_instance() {
    return *internal_default_instance();
  }
  static inline const S_Move* internal_default_instance() {
    return reinterpret_cast<const S_Move*>(
               &_S_Move_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(S_Move& a, S_Move& b) {
    a.Swap(&b);
  }
  inline void Swap(S_Move* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(S_Move* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  S_Move* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<S_Move>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const S_Move& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const S_Move& from) {
    S_Move::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(S_Move* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.S_Move";
  }
  protected:
  explicit S_Move(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kInfoFieldNumber = 1,
  };
  // .Protocol.ObjectInfo info = 1;
  bool has_info() const;
  private:
  bool _internal_has_info() const;
  public:
  void clear_info();
  const ::Protocol::ObjectInfo& info() const;
  PROTOBUF_NODISCARD ::Protocol::ObjectInfo* release_info();
  ::Protocol::ObjectInfo* mutable_info();
  void set_allocated_info(::Protocol::ObjectInfo* info);
  private:
  const ::Protocol::ObjectInfo& _internal_info() const;
  ::Protocol::ObjectInfo* _internal_mutable_info();
  public:
  void unsafe_arena_set_allocated_info(
      ::Protocol::ObjectInfo* info);
  ::Protocol::ObjectInfo* unsafe_arena_release_info();

  // @@protoc_insertion_point(class_scope:Protocol.S_Move)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::Protocol::ObjectInfo* info_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class C_Turn final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.C_Turn) */ {
 public:
  inline C_Turn() : C_Turn(nullptr) {}
  ~C_Turn() override;
  explicit PROTOBUF_CONSTEXPR C_Turn(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  C_Turn(const C_Turn& from);
  C_Turn(C_Turn&& from) noexcept
    : C_Turn() {
    *this = ::std::move(from);
  }

  inline C_Turn& operator=(const C_Turn& from) {
    CopyFrom(from);
    return *this;
  }
  inline C_Turn& operator=(C_Turn&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const C_Turn& default_instance() {
    return *internal_default_instance();
  }
  static inline const C_Turn* internal_default_instance() {
    return reinterpret_cast<const C_Turn*>(
               &_C_Turn_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(C_Turn& a, C_Turn& b) {
    a.Swap(&b);
  }
  inline void Swap(C_Turn* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(C_Turn* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  C_Turn* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<C_Turn>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const C_Turn& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const C_Turn& from) {
    C_Turn::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(C_Turn* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.C_Turn";
  }
  protected:
  explicit C_Turn(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDirFieldNumber = 1,
  };
  // .Protocol.DIR_TYPE dir = 1;
  void clear_dir();
  ::Protocol::DIR_TYPE dir() const;
  void set_dir(::Protocol::DIR_TYPE value);
  private:
  ::Protocol::DIR_TYPE _internal_dir() const;
  void _internal_set_dir(::Protocol::DIR_TYPE value);
  public:

  // @@protoc_insertion_point(class_scope:Protocol.C_Turn)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int dir_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class S_Turn final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.S_Turn) */ {
 public:
  inline S_Turn() : S_Turn(nullptr) {}
  ~S_Turn() override;
  explicit PROTOBUF_CONSTEXPR S_Turn(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  S_Turn(const S_Turn& from);
  S_Turn(S_Turn&& from) noexcept
    : S_Turn() {
    *this = ::std::move(from);
  }

  inline S_Turn& operator=(const S_Turn& from) {
    CopyFrom(from);
    return *this;
  }
  inline S_Turn& operator=(S_Turn&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const S_Turn& default_instance() {
    return *internal_default_instance();
  }
  static inline const S_Turn* internal_default_instance() {
    return reinterpret_cast<const S_Turn*>(
               &_S_Turn_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(S_Turn& a, S_Turn& b) {
    a.Swap(&b);
  }
  inline void Swap(S_Turn* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(S_Turn* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  S_Turn* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<S_Turn>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const S_Turn& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const S_Turn& from) {
    S_Turn::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(S_Turn* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.S_Turn";
  }
  protected:
  explicit S_Turn(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kInfoFieldNumber = 1,
  };
  // .Protocol.ObjectInfo info = 1;
  bool has_info() const;
  private:
  bool _internal_has_info() const;
  public:
  void clear_info();
  const ::Protocol::ObjectInfo& info() const;
  PROTOBUF_NODISCARD ::Protocol::ObjectInfo* release_info();
  ::Protocol::ObjectInfo* mutable_info();
  void set_allocated_info(::Protocol::ObjectInfo* info);
  private:
  const ::Protocol::ObjectInfo& _internal_info() const;
  ::Protocol::ObjectInfo* _internal_mutable_info();
  public:
  void unsafe_arena_set_allocated_info(
      ::Protocol::ObjectInfo* info);
  ::Protocol::ObjectInfo* unsafe_arena_release_info();

  // @@protoc_insertion_point(class_scope:Protocol.S_Turn)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::Protocol::ObjectInfo* info_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class C_Attack final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.C_Attack) */ {
 public:
  inline C_Attack() : C_Attack(nullptr) {}
  ~C_Attack() override;
  explicit PROTOBUF_CONSTEXPR C_Attack(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  C_Attack(const C_Attack& from);
  C_Attack(C_Attack&& from) noexcept
    : C_Attack() {
    *this = ::std::move(from);
  }

  inline C_Attack& operator=(const C_Attack& from) {
    CopyFrom(from);
    return *this;
  }
  inline C_Attack& operator=(C_Attack&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const C_Attack& default_instance() {
    return *internal_default_instance();
  }
  static inline const C_Attack* internal_default_instance() {
    return reinterpret_cast<const C_Attack*>(
               &_C_Attack_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(C_Attack& a, C_Attack& b) {
    a.Swap(&b);
  }
  inline void Swap(C_Attack* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(C_Attack* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  C_Attack* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<C_Attack>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const C_Attack& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const C_Attack& from) {
    C_Attack::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(C_Attack* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.C_Attack";
  }
  protected:
  explicit C_Attack(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDirFieldNumber = 1,
    kWeaponTypeFieldNumber = 2,
  };
  // .Protocol.DIR_TYPE dir = 1;
  void clear_dir();
  ::Protocol::DIR_TYPE dir() const;
  void set_dir(::Protocol::DIR_TYPE value);
  private:
  ::Protocol::DIR_TYPE _internal_dir() const;
  void _internal_set_dir(::Protocol::DIR_TYPE value);
  public:

  // .Protocol.WEAPON_TYPE weaponType = 2;
  void clear_weapontype();
  ::Protocol::WEAPON_TYPE weapontype() const;
  void set_weapontype(::Protocol::WEAPON_TYPE value);
  private:
  ::Protocol::WEAPON_TYPE _internal_weapontype() const;
  void _internal_set_weapontype(::Protocol::WEAPON_TYPE value);
  public:

  // @@protoc_insertion_point(class_scope:Protocol.C_Attack)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int dir_;
    int weapontype_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class S_Attack final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.S_Attack) */ {
 public:
  inline S_Attack() : S_Attack(nullptr) {}
  ~S_Attack() override;
  explicit PROTOBUF_CONSTEXPR S_Attack(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  S_Attack(const S_Attack& from);
  S_Attack(S_Attack&& from) noexcept
    : S_Attack() {
    *this = ::std::move(from);
  }

  inline S_Attack& operator=(const S_Attack& from) {
    CopyFrom(from);
    return *this;
  }
  inline S_Attack& operator=(S_Attack&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const S_Attack& default_instance() {
    return *internal_default_instance();
  }
  static inline const S_Attack* internal_default_instance() {
    return reinterpret_cast<const S_Attack*>(
               &_S_Attack_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(S_Attack& a, S_Attack& b) {
    a.Swap(&b);
  }
  inline void Swap(S_Attack* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(S_Attack* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  S_Attack* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<S_Attack>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const S_Attack& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const S_Attack& from) {
    S_Attack::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(S_Attack* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.S_Attack";
  }
  protected:
  explicit S_Attack(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAttackerIdFieldNumber = 1,
    kDirFieldNumber = 2,
    kWeaponTypeFieldNumber = 3,
  };
  // uint64 attackerId = 1;
  void clear_attackerid();
  uint64_t attackerid() const;
  void set_attackerid(uint64_t value);
  private:
  uint64_t _internal_attackerid() const;
  void _internal_set_attackerid(uint64_t value);
  public:

  // .Protocol.DIR_TYPE dir = 2;
  void clear_dir();
  ::Protocol::DIR_TYPE dir() const;
  void set_dir(::Protocol::DIR_TYPE value);
  private:
  ::Protocol::DIR_TYPE _internal_dir() const;
  void _internal_set_dir(::Protocol::DIR_TYPE value);
  public:

  // .Protocol.WEAPON_TYPE weaponType = 3;
  void clear_weapontype();
  ::Protocol::WEAPON_TYPE weapontype() const;
  void set_weapontype(::Protocol::WEAPON_TYPE value);
  private:
  ::Protocol::WEAPON_TYPE _internal_weapontype() const;
  void _internal_set_weapontype(::Protocol::WEAPON_TYPE value);
  public:

  // @@protoc_insertion_point(class_scope:Protocol.S_Attack)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    uint64_t attackerid_;
    int dir_;
    int weapontype_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class S_Damaged final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.S_Damaged) */ {
 public:
  inline S_Damaged() : S_Damaged(nullptr) {}
  ~S_Damaged() override;
  explicit PROTOBUF_CONSTEXPR S_Damaged(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  S_Damaged(const S_Damaged& from);
  S_Damaged(S_Damaged&& from) noexcept
    : S_Damaged() {
    *this = ::std::move(from);
  }

  inline S_Damaged& operator=(const S_Damaged& from) {
    CopyFrom(from);
    return *this;
  }
  inline S_Damaged& operator=(S_Damaged&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const S_Damaged& default_instance() {
    return *internal_default_instance();
  }
  static inline const S_Damaged* internal_default_instance() {
    return reinterpret_cast<const S_Damaged*>(
               &_S_Damaged_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(S_Damaged& a, S_Damaged& b) {
    a.Swap(&b);
  }
  inline void Swap(S_Damaged* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(S_Damaged* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  S_Damaged* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<S_Damaged>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const S_Damaged& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const S_Damaged& from) {
    S_Damaged::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(S_Damaged* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.S_Damaged";
  }
  protected:
  explicit S_Damaged(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAttackerIdFieldNumber = 1,
    kTargetIdFieldNumber = 2,
    kNewHpFieldNumber = 3,
    kDamageFieldNumber = 4,
  };
  // uint64 attackerId = 1;
  void clear_attackerid();
  uint64_t attackerid() const;
  void set_attackerid(uint64_t value);
  private:
  uint64_t _internal_attackerid() const;
  void _internal_set_attackerid(uint64_t value);
  public:

  // uint64 targetId = 2;
  void clear_targetid();
  uint64_t targetid() const;
  void set_targetid(uint64_t value);
  private:
  uint64_t _internal_targetid() const;
  void _internal_set_targetid(uint64_t value);
  public:

  // int32 newHp = 3;
  void clear_newhp();
  int32_t newhp() const;
  void set_newhp(int32_t value);
  private:
  int32_t _internal_newhp() const;
  void _internal_set_newhp(int32_t value);
  public:

  // int32 damage = 4;
  void clear_damage();
  int32_t damage() const;
  void set_damage(int32_t value);
  private:
  int32_t _internal_damage() const;
  void _internal_set_damage(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:Protocol.S_Damaged)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    uint64_t attackerid_;
    uint64_t targetid_;
    int32_t newhp_;
    int32_t damage_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class C_ChangeMap final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.C_ChangeMap) */ {
 public:
  inline C_ChangeMap() : C_ChangeMap(nullptr) {}
  ~C_ChangeMap() override;
  explicit PROTOBUF_CONSTEXPR C_ChangeMap(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  C_ChangeMap(const C_ChangeMap& from);
  C_ChangeMap(C_ChangeMap&& from) noexcept
    : C_ChangeMap() {
    *this = ::std::move(from);
  }

  inline C_ChangeMap& operator=(const C_ChangeMap& from) {
    CopyFrom(from);
    return *this;
  }
  inline C_ChangeMap& operator=(C_ChangeMap&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const C_ChangeMap& default_instance() {
    return *internal_default_instance();
  }
  static inline const C_ChangeMap* internal_default_instance() {
    return reinterpret_cast<const C_ChangeMap*>(
               &_C_ChangeMap_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(C_ChangeMap& a, C_ChangeMap& b) {
    a.Swap(&b);
  }
  inline void Swap(C_ChangeMap* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(C_ChangeMap* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  C_ChangeMap* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<C_ChangeMap>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const C_ChangeMap& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const C_ChangeMap& from) {
    C_ChangeMap::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(C_ChangeMap* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.C_ChangeMap";
  }
  protected:
  explicit C_ChangeMap(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMapIdFieldNumber = 1,
    kChannelFieldNumber = 2,
  };
  // .Protocol.MAP_ID mapId = 1;
  void clear_mapid();
  ::Protocol::MAP_ID mapid() const;
  void set_mapid(::Protocol::MAP_ID value);
  private:
  ::Protocol::MAP_ID _internal_mapid() const;
  void _internal_set_mapid(::Protocol::MAP_ID value);
  public:

  // int32 channel = 2;
  void clear_channel();
  int32_t channel() const;
  void set_channel(int32_t value);
  private:
  int32_t _internal_channel() const;
  void _internal_set_channel(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:Protocol.C_ChangeMap)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int mapid_;
    int32_t channel_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class S_ChangeMap final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.S_ChangeMap) */ {
 public:
  inline S_ChangeMap() : S_ChangeMap(nullptr) {}
  ~S_ChangeMap() override;
  explicit PROTOBUF_CONSTEXPR S_ChangeMap(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  S_ChangeMap(const S_ChangeMap& from);
  S_ChangeMap(S_ChangeMap&& from) noexcept
    : S_ChangeMap() {
    *this = ::std::move(from);
  }

  inline S_ChangeMap& operator=(const S_ChangeMap& from) {
    CopyFrom(from);
    return *this;
  }
  inline S_ChangeMap& operator=(S_ChangeMap&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const S_ChangeMap& default_instance() {
    return *internal_default_instance();
  }
  static inline const S_ChangeMap* internal_default_instance() {
    return reinterpret_cast<const S_ChangeMap*>(
               &_S_ChangeMap_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(S_ChangeMap& a, S_ChangeMap& b) {
    a.Swap(&b);
  }
  inline void Swap(S_ChangeMap* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(S_ChangeMap* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  S_ChangeMap* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<S_ChangeMap>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const S_ChangeMap& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const S_ChangeMap& from) {
    S_ChangeMap::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(S_ChangeMap* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.S_ChangeMap";
  }
  protected:
  explicit S_ChangeMap(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSuccessFieldNumber = 1,
    kMapIdFieldNumber = 2,
    kInstanceIdFieldNumber = 4,
    kChannelFieldNumber = 3,
  };
  // bool success = 1;
  void clear_success();
  bool success() const;
  void set_success(bool value);
  private:
  bool _internal_success() const;
  void _internal_set_success(bool value);
  public:

  // .Protocol.MAP_ID mapId = 2;
  void clear_mapid();
  ::Protocol::MAP_ID mapid() const;
  void set_mapid(::Protocol::MAP_ID value);
  private:
  ::Protocol::MAP_ID _internal_mapid() const;
  void _internal_set_mapid(::Protocol::MAP_ID value);
  public:

  // uint64 instanceId = 4;
  void clear_instanceid();
  uint64_t instanceid() const;
  void set_instanceid(uint64_t value);
  private:
  uint64_t _internal_instanceid() const;
  void _internal_set_instanceid(uint64_t value);
  public:

  // int32 channel = 3;
  void clear_channel();
  int32_t channel() const;
  void set_channel(int32_t value);
  private:
  int32_t _internal_channel() const;
  void _internal_set_channel(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:Protocol.S_ChangeMap)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    bool success_;
    int mapid_;
    uint64_t instanceid_;
    int32_t channel_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class S_GainExp final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.S_GainExp) */ {
 public:
  inline S_GainExp() : S_GainExp(nullptr) {}
  ~S_GainExp() override;
  explicit PROTOBUF_CONSTEXPR S_GainExp(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  S_GainExp(const S_GainExp& from);
  S_GainExp(S_GainExp&& from) noexcept
    : S_GainExp() {
    *this = ::std::move(from);
  }

  inline S_GainExp& operator=(const S_GainExp& from) {
    CopyFrom(from);
    return *this;
  }
  inline S_GainExp& operator=(S_GainExp&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const S_GainExp& default_instance() {
    return *internal_default_instance();
  }
  static inline const S_GainExp* internal_default_instance() {
    return reinterpret_cast<const S_GainExp*>(
               &_S_GainExp_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(S_GainExp& a, S_GainExp& b) {
    a.Swap(&b);
  }
  inline void Swap(S_GainExp* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(S_GainExp* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  S_GainExp* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<S_GainExp>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const S_GainExp& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const S_GainExp& from) {
    S_GainExp::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(S_GainExp* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.S_GainExp";
  }
  protected:
  explicit S_GainExp(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPlayerIdFieldNumber = 1,
    kGainedExpFieldNumber = 2,
    kCurrentExpFieldNumber = 3,
    kMaxExpFieldNumber = 4,
  };
  // uint64 playerId = 1;
  void clear_playerid();
  uint64_t playerid() const;
  void set_playerid(uint64_t value);
  private:
  uint64_t _internal_playerid() const;
  void _internal_set_playerid(uint64_t value);
  public:

  // int32 gainedExp = 2;
  void clear_gainedexp();
  int32_t gainedexp() const;
  void set_gainedexp(int32_t value);
  private:
  int32_t _internal_gainedexp() const;
  void _internal_set_gainedexp(int32_t value);
  public:

  // int32 currentExp = 3;
  void clear_currentexp();
  int32_t currentexp() const;
  void set_currentexp(int32_t value);
  private:
  int32_t _internal_currentexp() const;
  void _internal_set_currentexp(int32_t value);
  public:

  // int32 maxExp = 4;
  void clear_maxexp();
  int32_t maxexp() const;
  void set_maxexp(int32_t value);
  private:
  int32_t _internal_maxexp() const;
  void _internal_set_maxexp(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:Protocol.S_GainExp)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    uint64_t playerid_;
    int32_t gainedexp_;
    int32_t currentexp_;
    int32_t maxexp_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class S_LevelUp final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.S_LevelUp) */ {
 public:
  inline S_LevelUp() : S_LevelUp(nullptr) {}
  ~S_LevelUp() override;
  explicit PROTOBUF_CONSTEXPR S_LevelUp(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  S_LevelUp(const S_LevelUp& from);
  S_LevelUp(S_LevelUp&& from) noexcept
    : S_LevelUp() {
    *this = ::std::move(from);
  }

  inline S_LevelUp& operator=(const S_LevelUp& from) {
    CopyFrom(from);
    return *this;
  }
  inline S_LevelUp& operator=(S_LevelUp&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const S_LevelUp& default_instance() {
    return *internal_default_instance();
  }
  static inline const S_LevelUp* internal_default_instance() {
    return reinterpret_cast<const S_LevelUp*>(
               &_S_LevelUp_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(S_LevelUp& a, S_LevelUp& b) {
    a.Swap(&b);
  }
  inline void Swap(S_LevelUp* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(S_LevelUp* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  S_LevelUp* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<S_LevelUp>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const S_LevelUp& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const S_LevelUp& from) {
    S_LevelUp::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(S_LevelUp* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.S_LevelUp";
  }
  protected:
  explicit S_LevelUp(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPlayerIdFieldNumber = 1,
    kNewLevelFieldNumber = 2,
    kMaxHpFieldNumber = 3,
    kAttackFieldNumber = 4,
    kDefenceFieldNumber = 5,
    kMaxExpFieldNumber = 6,
  };
  // uint64 playerId = 1;
  void clear_playerid();
  uint64_t playerid() const;
  void set_playerid(uint64_t value);
  private:
  uint64_t _internal_playerid() const;
  void _internal_set_playerid(uint64_t value);
  public:

  // int32 newLevel = 2;
  void clear_newlevel();
  int32_t newlevel() const;
  void set_newlevel(int32_t value);
  private:
  int32_t _internal_newlevel() const;
  void _internal_set_newlevel(int32_t value);
  public:

  // int32 maxHp = 3;
  void clear_maxhp();
  int32_t maxhp() const;
  void set_maxhp(int32_t value);
  private:
  int32_t _internal_maxhp() const;
  void _internal_set_maxhp(int32_t value);
  public:

  // int32 attack = 4;
  void clear_attack();
  int32_t attack() const;
  void set_attack(int32_t value);
  private:
  int32_t _internal_attack() const;
  void _internal_set_attack(int32_t value);
  public:

  // int32 defence = 5;
  void clear_defence();
  int32_t defence() const;
  void set_defence(int32_t value);
  private:
  int32_t _internal_defence() const;
  void _internal_set_defence(int32_t value);
  public:

  // int32 maxExp = 6;
  void clear_maxexp();
  int32_t maxexp() const;
  void set_maxexp(int32_t value);
  private:
  int32_t _internal_maxexp() const;
  void _internal_set_maxexp(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:Protocol.S_LevelUp)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    uint64_t playerid_;
    int32_t newlevel_;
    int32_t maxhp_;
    int32_t attack_;
    int32_t defence_;
    int32_t maxexp_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class S_InventoryData final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.S_InventoryData) */ {
 public:
  inline S_InventoryData() : S_InventoryData(nullptr) {}
  ~S_InventoryData() override;
  explicit PROTOBUF_CONSTEXPR S_InventoryData(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  S_InventoryData(const S_InventoryData& from);
  S_InventoryData(S_InventoryData&& from) noexcept
    : S_InventoryData() {
    *this = ::std::move(from);
  }

  inline S_InventoryData& operator=(const S_InventoryData& from) {
    CopyFrom(from);
    return *this;
  }
  inline S_InventoryData& operator=(S_InventoryData&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const S_InventoryData& default_instance() {
    return *internal_default_instance();
  }
  static inline const S_InventoryData* internal_default_instance() {
    return reinterpret_cast<const S_InventoryData*>(
               &_S_InventoryData_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(S_InventoryData& a, S_InventoryData& b) {
    a.Swap(&b);
  }
  inline void Swap(S_InventoryData* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(S_InventoryData* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  S_InventoryData* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<S_InventoryData>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const S_InventoryData& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const S_InventoryData& from) {
    S_InventoryData::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(S_InventoryData* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.S_InventoryData";
  }
  protected:
  explicit S_InventoryData(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kItemsFieldNumber = 1,
    kEquippedWeaponFieldNumber = 2,
    kEquippedArmorFieldNumber = 3,
    kEquippedPotionFieldNumber = 4,
  };
  // repeated .Protocol.ItemInfo items = 1;
  int items_size() const;
  private:
  int _internal_items_size() const;
  public:
  void clear_items();
  ::Protocol::ItemInfo* mutable_items(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Protocol::ItemInfo >*
      mutable_items();
  private:
  const ::Protocol::ItemInfo& _internal_items(int index) const;
  ::Protocol::ItemInfo* _internal_add_items();
  public:
  const ::Protocol::ItemInfo& items(int index) const;
  ::Protocol::ItemInfo* add_items();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Protocol::ItemInfo >&
      items() const;

  // .Protocol.ItemInfo equippedWeapon = 2;
  bool has_equippedweapon() const;
  private:
  bool _internal_has_equippedweapon() const;
  public:
  void clear_equippedweapon();
  const ::Protocol::ItemInfo& equippedweapon() const;
  PROTOBUF_NODISCARD ::Protocol::ItemInfo* release_equippedweapon();
  ::Protocol::ItemInfo* mutable_equippedweapon();
  void set_allocated_equippedweapon(::Protocol::ItemInfo* equippedweapon);
  private:
  const ::Protocol::ItemInfo& _internal_equippedweapon() const;
  ::Protocol::ItemInfo* _internal_mutable_equippedweapon();
  public:
  void unsafe_arena_set_allocated_equippedweapon(
      ::Protocol::ItemInfo* equippedweapon);
  ::Protocol::ItemInfo* unsafe_arena_release_equippedweapon();

  // .Protocol.ItemInfo equippedArmor = 3;
  bool has_equippedarmor() const;
  private:
  bool _internal_has_equippedarmor() const;
  public:
  void clear_equippedarmor();
  const ::Protocol::ItemInfo& equippedarmor() const;
  PROTOBUF_NODISCARD ::Protocol::ItemInfo* release_equippedarmor();
  ::Protocol::ItemInfo* mutable_equippedarmor();
  void set_allocated_equippedarmor(::Protocol::ItemInfo* equippedarmor);
  private:
  const ::Protocol::ItemInfo& _internal_equippedarmor() const;
  ::Protocol::ItemInfo* _internal_mutable_equippedarmor();
  public:
  void unsafe_arena_set_allocated_equippedarmor(
      ::Protocol::ItemInfo* equippedarmor);
  ::Protocol::ItemInfo* unsafe_arena_release_equippedarmor();

  // .Protocol.ItemInfo equippedPotion = 4;
  bool has_equippedpotion() const;
  private:
  bool _internal_has_equippedpotion() const;
  public:
  void clear_equippedpotion();
  const ::Protocol::ItemInfo& equippedpotion() const;
  PROTOBUF_NODISCARD ::Protocol::ItemInfo* release_equippedpotion();
  ::Protocol::ItemInfo* mutable_equippedpotion();
  void set_allocated_equippedpotion(::Protocol::ItemInfo* equippedpotion);
  private:
  const ::Protocol::ItemInfo& _internal_equippedpotion() const;
  ::Protocol::ItemInfo* _internal_mutable_equippedpotion();
  public:
  void unsafe_arena_set_allocated_equippedpotion(
      ::Protocol::ItemInfo* equippedpotion);
  ::Protocol::ItemInfo* unsafe_arena_release_equippedpotion();

  // @@protoc_insertion_point(class_scope:Protocol.S_InventoryData)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Protocol::ItemInfo > items_;
    ::Protocol::ItemInfo* equippedweapon_;
    ::Protocol::ItemInfo* equippedarmor_;
    ::Protocol::ItemInfo* equippedpotion_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class S_AddItem final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.S_AddItem) */ {
 public:
  inline S_AddItem() : S_AddItem(nullptr) {}
  ~S_AddItem() override;
  explicit PROTOBUF_CONSTEXPR S_AddItem(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  S_AddItem(const S_AddItem& from);
  S_AddItem(S_AddItem&& from) noexcept
    : S_AddItem() {
    *this = ::std::move(from);
  }

  inline S_AddItem& operator=(const S_AddItem& from) {
    CopyFrom(from);
    return *this;
  }
  inline S_AddItem& operator=(S_AddItem&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const S_AddItem& default_instance() {
    return *internal_default_instance();
  }
  static inline const S_AddItem* internal_default_instance() {
    return reinterpret_cast<const S_AddItem*>(
               &_S_AddItem_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  friend void swap(S_AddItem& a, S_AddItem& b) {
    a.Swap(&b);
  }
  inline void Swap(S_AddItem* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(S_AddItem* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  S_AddItem* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<S_AddItem>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const S_AddItem& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const S_AddItem& from) {
    S_AddItem::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(S_AddItem* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.S_AddItem";
  }
  protected:
  explicit S_AddItem(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kItemIdFieldNumber = 1,
    kSlotFieldNumber = 2,
    kCountFieldNumber = 3,
  };
  // int32 itemId = 1;
  void clear_itemid();
  int32_t itemid() const;
  void set_itemid(int32_t value);
  private:
  int32_t _internal_itemid() const;
  void _internal_set_itemid(int32_t value);
  public:

  // int32 slot = 2;
  void clear_slot();
  int32_t slot() const;
  void set_slot(int32_t value);
  private:
  int32_t _internal_slot() const;
  void _internal_set_slot(int32_t value);
  public:

  // int32 count = 3;
  void clear_count();
  int32_t count() const;
  void set_count(int32_t value);
  private:
  int32_t _internal_count() const;
  void _internal_set_count(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:Protocol.S_AddItem)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int32_t itemid_;
    int32_t slot_;
    int32_t count_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class S_EquipItem final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.S_EquipItem) */ {
 public:
  inline S_EquipItem() : S_EquipItem(nullptr) {}
  ~S_EquipItem() override;
  explicit PROTOBUF_CONSTEXPR S_EquipItem(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  S_EquipItem(const S_EquipItem& from);
  S_EquipItem(S_EquipItem&& from) noexcept
    : S_EquipItem() {
    *this = ::std::move(from);
  }

  inline S_EquipItem& operator=(const S_EquipItem& from) {
    CopyFrom(from);
    return *this;
  }
  inline S_EquipItem& operator=(S_EquipItem&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const S_EquipItem& default_instance() {
    return *internal_default_instance();
  }
  static inline const S_EquipItem* internal_default_instance() {
    return reinterpret_cast<const S_EquipItem*>(
               &_S_EquipItem_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  friend void swap(S_EquipItem& a, S_EquipItem& b) {
    a.Swap(&b);
  }
  inline void Swap(S_EquipItem* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(S_EquipItem* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  S_EquipItem* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<S_EquipItem>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const S_EquipItem& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const S_EquipItem& from) {
    S_EquipItem::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(S_EquipItem* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.S_EquipItem";
  }
  protected:
  explicit S_EquipItem(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEquipTypeFieldNumber = 1,
    kStorageSlotFieldNumber = 2,
    kStorageItemIdFieldNumber = 3,
    kStorageItemCountFieldNumber = 4,
    kEquipItemIdFieldNumber = 5,
    kEquipItemCountFieldNumber = 6,
    kAttackFieldNumber = 7,
    kDefenceFieldNumber = 8,
  };
  // int32 equipType = 1;
  void clear_equiptype();
  int32_t equiptype() const;
  void set_equiptype(int32_t value);
  private:
  int32_t _internal_equiptype() const;
  void _internal_set_equiptype(int32_t value);
  public:

  // int32 storageSlot = 2;
  void clear_storageslot();
  int32_t storageslot() const;
  void set_storageslot(int32_t value);
  private:
  int32_t _internal_storageslot() const;
  void _internal_set_storageslot(int32_t value);
  public:

  // int32 storageItemId = 3;
  void clear_storageitemid();
  int32_t storageitemid() const;
  void set_storageitemid(int32_t value);
  private:
  int32_t _internal_storageitemid() const;
  void _internal_set_storageitemid(int32_t value);
  public:

  // int32 storageItemCount = 4;
  void clear_storageitemcount();
  int32_t storageitemcount() const;
  void set_storageitemcount(int32_t value);
  private:
  int32_t _internal_storageitemcount() const;
  void _internal_set_storageitemcount(int32_t value);
  public:

  // int32 equipItemId = 5;
  void clear_equipitemid();
  int32_t equipitemid() const;
  void set_equipitemid(int32_t value);
  private:
  int32_t _internal_equipitemid() const;
  void _internal_set_equipitemid(int32_t value);
  public:

  // int32 equipItemCount = 6;
  void clear_equipitemcount();
  int32_t equipitemcount() const;
  void set_equipitemcount(int32_t value);
  private:
  int32_t _internal_equipitemcount() const;
  void _internal_set_equipitemcount(int32_t value);
  public:

  // int32 attack = 7;
  void clear_attack();
  int32_t attack() const;
  void set_attack(int32_t value);
  private:
  int32_t _internal_attack() const;
  void _internal_set_attack(int32_t value);
  public:

  // int32 defence = 8;
  void clear_defence();
  int32_t defence() const;
  void set_defence(int32_t value);
  private:
  int32_t _internal_defence() const;
  void _internal_set_defence(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:Protocol.S_EquipItem)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int32_t equiptype_;
    int32_t storageslot_;
    int32_t storageitemid_;
    int32_t storageitemcount_;
    int32_t equipitemid_;
    int32_t equipitemcount_;
    int32_t attack_;
    int32_t defence_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class S_UnequipItem final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.S_UnequipItem) */ {
 public:
  inline S_UnequipItem() : S_UnequipItem(nullptr) {}
  ~S_UnequipItem() override;
  explicit PROTOBUF_CONSTEXPR S_UnequipItem(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  S_UnequipItem(const S_UnequipItem& from);
  S_UnequipItem(S_UnequipItem&& from) noexcept
    : S_UnequipItem() {
    *this = ::std::move(from);
  }

  inline S_UnequipItem& operator=(const S_UnequipItem& from) {
    CopyFrom(from);
    return *this;
  }
  inline S_UnequipItem& operator=(S_UnequipItem&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const S_UnequipItem& default_instance() {
    return *internal_default_instance();
  }
  static inline const S_UnequipItem* internal_default_instance() {
    return reinterpret_cast<const S_UnequipItem*>(
               &_S_UnequipItem_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  friend void swap(S_UnequipItem& a, S_UnequipItem& b) {
    a.Swap(&b);
  }
  inline void Swap(S_UnequipItem* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(S_UnequipItem* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  S_UnequipItem* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<S_UnequipItem>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const S_UnequipItem& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const S_UnequipItem& from) {
    S_UnequipItem::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(S_UnequipItem* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.S_UnequipItem";
  }
  protected:
  explicit S_UnequipItem(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEquipTypeFieldNumber = 1,
    kStorageSlotFieldNumber = 2,
    kAttackFieldNumber = 3,
    kDefenceFieldNumber = 4,
  };
  // int32 equipType = 1;
  void clear_equiptype();
  int32_t equiptype() const;
  void set_equiptype(int32_t value);
  private:
  int32_t _internal_equiptype() const;
  void _internal_set_equiptype(int32_t value);
  public:

  // int32 storageSlot = 2;
  void clear_storageslot();
  int32_t storageslot() const;
  void set_storageslot(int32_t value);
  private:
  int32_t _internal_storageslot() const;
  void _internal_set_storageslot(int32_t value);
  public:

  // int32 attack = 3;
  void clear_attack();
  int32_t attack() const;
  void set_attack(int32_t value);
  private:
  int32_t _internal_attack() const;
  void _internal_set_attack(int32_t value);
  public:

  // int32 defence = 4;
  void clear_defence();
  int32_t defence() const;
  void set_defence(int32_t value);
  private:
  int32_t _internal_defence() const;
  void _internal_set_defence(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:Protocol.S_UnequipItem)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int32_t equiptype_;
    int32_t storageslot_;
    int32_t attack_;
    int32_t defence_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class S_UseItem final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.S_UseItem) */ {
 public:
  inline S_UseItem() : S_UseItem(nullptr) {}
  ~S_UseItem() override;
  explicit PROTOBUF_CONSTEXPR S_UseItem(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  S_UseItem(const S_UseItem& from);
  S_UseItem(S_UseItem&& from) noexcept
    : S_UseItem() {
    *this = ::std::move(from);
  }

  inline S_UseItem& operator=(const S_UseItem& from) {
    CopyFrom(from);
    return *this;
  }
  inline S_UseItem& operator=(S_UseItem&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const S_UseItem& default_instance() {
    return *internal_default_instance();
  }
  static inline const S_UseItem* internal_default_instance() {
    return reinterpret_cast<const S_UseItem*>(
               &_S_UseItem_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    20;

  friend void swap(S_UseItem& a, S_UseItem& b) {
    a.Swap(&b);
  }
  inline void Swap(S_UseItem* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(S_UseItem* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  S_UseItem* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<S_UseItem>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const S_UseItem& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const S_UseItem& from) {
    S_UseItem::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(S_UseItem* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.S_UseItem";
  }
  protected:
  explicit S_UseItem(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEquipTypeFieldNumber = 1,
    kRemainCountFieldNumber = 2,
    kNewHpFieldNumber = 3,
  };
  // int32 equipType = 1;
  void clear_equiptype();
  int32_t equiptype() const;
  void set_equiptype(int32_t value);
  private:
  int32_t _internal_equiptype() const;
  void _internal_set_equiptype(int32_t value);
  public:

  // int32 remainCount = 2;
  void clear_remaincount();
  int32_t remaincount() const;
  void set_remaincount(int32_t value);
  private:
  int32_t _internal_remaincount() const;
  void _internal_set_remaincount(int32_t value);
  public:

  // int32 newHp = 3;
  void clear_newhp();
  int32_t newhp() const;
  void set_newhp(int32_t value);
  private:
  int32_t _internal_newhp() const;
  void _internal_set_newhp(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:Protocol.S_UseItem)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int32_t equiptype_;
    int32_t remaincount_;
    int32_t newhp_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class C_EquipItem final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.C_EquipItem) */ {
 public:
  inline C_EquipItem() : C_EquipItem(nullptr) {}
  ~C_EquipItem() override;
  explicit PROTOBUF_CONSTEXPR C_EquipItem(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  C_EquipItem(const C_EquipItem& from);
  C_EquipItem(C_EquipItem&& from) noexcept
    : C_EquipItem() {
    *this = ::std::move(from);
  }

  inline C_EquipItem& operator=(const C_EquipItem& from) {
    CopyFrom(from);
    return *this;
  }
  inline C_EquipItem& operator=(C_EquipItem&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const C_EquipItem& default_instance() {
    return *internal_default_instance();
  }
  static inline const C_EquipItem* internal_default_instance() {
    return reinterpret_cast<const C_EquipItem*>(
               &_C_EquipItem_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    21;

  friend void swap(C_EquipItem& a, C_EquipItem& b) {
    a.Swap(&b);
  }
  inline void Swap(C_EquipItem* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(C_EquipItem* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  C_EquipItem* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<C_EquipItem>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const C_EquipItem& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const C_EquipItem& from) {
    C_EquipItem::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(C_EquipItem* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.C_EquipItem";
  }
  protected:
  explicit C_EquipItem(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSlotFieldNumber = 1,
  };
  // int32 slot = 1;
  void clear_slot();
  int32_t slot() const;
  void set_slot(int32_t value);
  private:
  int32_t _internal_slot() const;
  void _internal_set_slot(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:Protocol.C_EquipItem)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int32_t slot_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class C_UnequipItem final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.C_UnequipItem) */ {
 public:
  inline C_UnequipItem() : C_UnequipItem(nullptr) {}
  ~C_UnequipItem() override;
  explicit PROTOBUF_CONSTEXPR C_UnequipItem(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  C_UnequipItem(const C_UnequipItem& from);
  C_UnequipItem(C_UnequipItem&& from) noexcept
    : C_UnequipItem() {
    *this = ::std::move(from);
  }

  inline C_UnequipItem& operator=(const C_UnequipItem& from) {
    CopyFrom(from);
    return *this;
  }
  inline C_UnequipItem& operator=(C_UnequipItem&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const C_UnequipItem& default_instance() {
    return *internal_default_instance();
  }
  static inline const C_UnequipItem* internal_default_instance() {
    return reinterpret_cast<const C_UnequipItem*>(
               &_C_UnequipItem_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    22;

  friend void swap(C_UnequipItem& a, C_UnequipItem& b) {
    a.Swap(&b);
  }
  inline void Swap(C_UnequipItem* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(C_UnequipItem* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  C_UnequipItem* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<C_UnequipItem>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const C_UnequipItem& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const C_UnequipItem& from) {
    C_UnequipItem::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(C_UnequipItem* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.C_UnequipItem";
  }
  protected:
  explicit C_UnequipItem(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEquipTypeFieldNumber = 1,
  };
  // int32 equipType = 1;
  void clear_equiptype();
  int32_t equiptype() const;
  void set_equiptype(int32_t value);
  private:
  int32_t _internal_equiptype() const;
  void _internal_set_equiptype(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:Protocol.C_UnequipItem)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int32_t equiptype_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class C_UseItem final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.C_UseItem) */ {
 public:
  inline C_UseItem() : C_UseItem(nullptr) {}
  ~C_UseItem() override;
  explicit PROTOBUF_CONSTEXPR C_UseItem(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  C_UseItem(const C_UseItem& from);
  C_UseItem(C_UseItem&& from) noexcept
    : C_UseItem() {
    *this = ::std::move(from);
  }

  inline C_UseItem& operator=(const C_UseItem& from) {
    CopyFrom(from);
    return *this;
  }
  inline C_UseItem& operator=(C_UseItem&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const C_UseItem& default_instance() {
    return *internal_default_instance();
  }
  static inline const C_UseItem* internal_default_instance() {
    return reinterpret_cast<const C_UseItem*>(
               &_C_UseItem_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    23;

  friend void swap(C_UseItem& a, C_UseItem& b) {
    a.Swap(&b);
  }
  inline void Swap(C_UseItem* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(C_UseItem* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  C_UseItem* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<C_UseItem>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const C_UseItem& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const C_UseItem& from) {
    C_UseItem::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(C_UseItem* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.C_UseItem";
  }
  protected:
  explicit C_UseItem(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSlotFieldNumber = 1,
  };
  // int32 slot = 1;
  void clear_slot();
  int32_t slot() const;
  void set_slot(int32_t value);
  private:
  int32_t _internal_slot() const;
  void _internal_set_slot(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:Protocol.C_UseItem)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int32_t slot_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class C_PartyInvite final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.C_PartyInvite) */ {
 public:
  inline C_PartyInvite() : C_PartyInvite(nullptr) {}
  ~C_PartyInvite() override;
  explicit PROTOBUF_CONSTEXPR C_PartyInvite(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  C_PartyInvite(const C_PartyInvite& from);
  C_PartyInvite(C_PartyInvite&& from) noexcept
    : C_PartyInvite() {
    *this = ::std::move(from);
  }

  inline C_PartyInvite& operator=(const C_PartyInvite& from) {
    CopyFrom(from);
    return *this;
  }
  inline C_PartyInvite& operator=(C_PartyInvite&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const C_PartyInvite& default_instance() {
    return *internal_default_instance();
  }
  static inline const C_PartyInvite* internal_default_instance() {
    return reinterpret_cast<const C_PartyInvite*>(
               &_C_PartyInvite_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    24;

  friend void swap(C_PartyInvite& a, C_PartyInvite& b) {
    a.Swap(&b);
  }
  inline void Swap(C_PartyInvite* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(C_PartyInvite* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  C_PartyInvite* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<C_PartyInvite>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const C_PartyInvite& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const C_PartyInvite& from) {
    C_PartyInvite::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(C_PartyInvite* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.C_PartyInvite";
  }
  protected:
  explicit C_PartyInvite(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTargetIdFieldNumber = 1,
  };
  // uint64 targetId = 1;
  void clear_targetid();
  uint64_t targetid() const;
  void set_targetid(uint64_t value);
  private:
  uint64_t _internal_targetid() const;
  void _internal_set_targetid(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:Protocol.C_PartyInvite)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    uint64_t targetid_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class C_PartyAnswer final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.C_PartyAnswer) */ {
 public:
  inline C_PartyAnswer() : C_PartyAnswer(nullptr) {}
  ~C_PartyAnswer() override;
  explicit PROTOBUF_CONSTEXPR C_PartyAnswer(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  C_PartyAnswer(const C_PartyAnswer& from);
  C_PartyAnswer(C_PartyAnswer&& from) noexcept
    : C_PartyAnswer() {
    *this = ::std::move(from);
  }

  inline C_PartyAnswer& operator=(const C_PartyAnswer& from) {
    CopyFrom(from);
    return *this;
  }
  inline C_PartyAnswer& operator=(C_PartyAnswer&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const C_PartyAnswer& default_instance() {
    return *internal_default_instance();
  }
  static inline const C_PartyAnswer* internal_default_instance() {
    return reinterpret_cast<const C_PartyAnswer*>(
               &_C_PartyAnswer_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    25;

  friend void swap(C_PartyAnswer& a, C_PartyAnswer& b) {
    a.Swap(&b);
  }
  inline void Swap(C_PartyAnswer* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(C_PartyAnswer* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  C_PartyAnswer* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<C_PartyAnswer>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const C_PartyAnswer& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const C_PartyAnswer& from) {
    C_PartyAnswer::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(C_PartyAnswer* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.C_PartyAnswer";
  }
  protected:
  explicit C_PartyAnswer(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kInviterIdFieldNumber = 1,
    kAcceptFieldNumber = 2,
  };
  // uint64 inviterId = 1;
  void clear_inviterid();
  uint64_t inviterid() const;
  void set_inviterid(uint64_t value);
  private:
  uint64_t _internal_inviterid() const;
  void _internal_set_inviterid(uint64_t value);
  public:

  // bool accept = 2;
  void clear_accept();
  bool accept() const;
  void set_accept(bool value);
  private:
  bool _internal_accept() const;
  void _internal_set_accept(bool value);
  public:

  // @@protoc_insertion_point(class_scope:Protocol.C_PartyAnswer)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    uint64_t inviterid_;
    bool accept_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class C_PartyLeave final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:Protocol.C_PartyLeave) */ {
 public:
  inline C_PartyLeave() : C_PartyLeave(nullptr) {}
  explicit PROTOBUF_CONSTEXPR C_PartyLeave(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  C_PartyLeave(const C_PartyLeave& from);
  C_PartyLeave(C_PartyLeave&& from) noexcept
    : C_PartyLeave() {
    *this = ::std::move(from);
  }

  inline C_PartyLeave& operator=(const C_PartyLeave& from) {
    CopyFrom(from);
    return *this;
  }
  inline C_PartyLeave& operator=(C_PartyLeave&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const C_PartyLeave& default_instance() {
    return *internal_default_instance();
  }
  static inline const C_PartyLeave* internal_default_instance() {
    return reinterpret_cast<const C_PartyLeave*>(
               &_C_PartyLeave_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    26;

  friend void swap(C_PartyLeave& a, C_PartyLeave& b) {
    a.Swap(&b);
  }
  inline void Swap(C_PartyLeave* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(C_PartyLeave* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  C_PartyLeave* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<C_PartyLeave>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const C_PartyLeave& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const C_PartyLeave& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.C_PartyLeave";
  }
  protected:
  explicit C_PartyLeave(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:Protocol.C_PartyLeave)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class S_PartyInvite final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.S_PartyInvite) */ {
 public:
  inline S_PartyInvite() : S_PartyInvite(nullptr) {}
  ~S_PartyInvite() override;
  explicit PROTOBUF_CONSTEXPR S_PartyInvite(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  S_PartyInvite(const S_PartyInvite& from);
  S_PartyInvite(S_PartyInvite&& from) noexcept
    : S_PartyInvite() {
    *this = ::std::move(from);
  }

  inline S_PartyInvite& operator=(const S_PartyInvite& from) {
    CopyFrom(from);
    return *this;
  }
  inline S_PartyInvite& operator=(S_PartyInvite&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const S_PartyInvite& default_instance() {
    return *internal_default_instance();
  }
  static inline const S_PartyInvite* internal_default_instance() {
    return reinterpret_cast<const S_PartyInvite*>(
               &_S_PartyInvite_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    27;

  friend void swap(S_PartyInvite& a, S_PartyInvite& b) {
    a.Swap(&b);
  }
  inline void Swap(S_PartyInvite* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(S_PartyInvite* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  S_PartyInvite* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<S_PartyInvite>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const S_PartyInvite& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const S_PartyInvite& from) {
    S_PartyInvite::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(S_PartyInvite* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.S_PartyInvite";
  }
  protected:
  explicit S_PartyInvite(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kInviterNameFieldNumber = 2,
    kInviterIdFieldNumber = 1,
  };
  // string inviterName = 2;
  void clear_invitername();
  const std::string& invitername() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_invitername(ArgT0&& arg0, ArgT... args);
  std::string* mutable_invitername();
  PROTOBUF_NODISCARD std::string* release_invitername();
  void set_allocated_invitername(std::string* invitername);
  private:
  const std::string& _internal_invitername() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_invitername(const std::string& value);
  std::string* _internal_mutable_invitername();
  public:

  // uint64 inviterId = 1;
  void clear_inviterid();
  uint64_t inviterid() const;
  void set_inviterid(uint64_t value);
  private:
  uint64_t _internal_inviterid() const;
  void _internal_set_inviterid(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:Protocol.S_PartyInvite)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr invitername_;
    uint64_t inviterid_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class S_PartyUpdate final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.S_PartyUpdate) */ {
 public:
  inline S_PartyUpdate() : S_PartyUpdate(nullptr) {}
  ~S_PartyUpdate() override;
  explicit PROTOBUF_CONSTEXPR S_PartyUpdate(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  S_PartyUpdate(const S_PartyUpdate& from);
  S_PartyUpdate(S_PartyUpdate&& from) noexcept
    : S_PartyUpdate() {
    *this = ::std::move(from);
  }

  inline S_PartyUpdate& operator=(const S_PartyUpdate& from) {
    CopyFrom(from);
    return *this;
  }
  inline S_PartyUpdate& operator=(S_PartyUpdate&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const S_PartyUpdate& default_instance() {
    return *internal_default_instance();
  }
  static inline const S_PartyUpdate* internal_default_instance() {
    return reinterpret_cast<const S_PartyUpdate*>(
               &_S_PartyUpdate_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    28;

  friend void swap(S_PartyUpdate& a, S_PartyUpdate& b) {
    a.Swap(&b);
  }
  inline void Swap(S_PartyUpdate* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(S_PartyUpdate* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  S_PartyUpdate* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<S_PartyUpdate>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const S_PartyUpdate& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const S_PartyUpdate& from) {
    S_PartyUpdate::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(S_PartyUpdate* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.S_PartyUpdate";
  }
  protected:
  explicit S_PartyUpdate(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMembersFieldNumber = 1,
  };
  // repeated .Protocol.PartyMemberInfo members = 1;
  int members_size() const;
  private:
  int _internal_members_size() const;
  public:
  void clear_members();
  ::Protocol::PartyMemberInfo* mutable_members(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Protocol::PartyMemberInfo >*
      mutable_members();
  private:
  const ::Protocol::PartyMemberInfo& _internal_members(int index) const;
  ::Protocol::PartyMemberInfo* _internal_add_members();
  public:
  const ::Protocol::PartyMemberInfo& members(int index) const;
  ::Protocol::PartyMemberInfo* add_members();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Protocol::PartyMemberInfo >&
      members() const;

  // @@protoc_insertion_point(class_scope:Protocol.S_PartyUpdate)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Protocol::PartyMemberInfo > members_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class S_PartyLeave final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:Protocol.S_PartyLeave) */ {
 public:
  inline S_PartyLeave() : S_PartyLeave(nullptr) {}
  explicit PROTOBUF_CONSTEXPR S_PartyLeave(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  S_PartyLeave(const S_PartyLeave& from);
  S_PartyLeave(S_PartyLeave&& from) noexcept
    : S_PartyLeave() {
    *this = ::std::move(from);
  }

  inline S_PartyLeave& operator=(const S_PartyLeave& from) {
    CopyFrom(from);
    return *this;
  }
  inline S_PartyLeave& operator=(S_PartyLeave&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const S_PartyLeave& default_instance() {
    return *internal_default_instance();
  }
  static inline const S_PartyLeave* internal_default_instance() {
    return reinterpret_cast<const S_PartyLeave*>(
               &_S_PartyLeave_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    29;

  friend void swap(S_PartyLeave& a, S_PartyLeave& b) {
    a.Swap(&b);
  }
  inline void Swap(S_PartyLeave* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(S_PartyLeave* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  S_PartyLeave* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<S_PartyLeave>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const S_PartyLeave& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const S_PartyLeave& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.S_PartyLeave";
  }
  protected:
  explicit S_PartyLeave(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:Protocol.S_PartyLeave)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class C_Login final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.C_Login) */ {
 public:
  inline C_Login() : C_Login(nullptr) {}
  ~C_Login() override;
  explicit PROTOBUF_CONSTEXPR C_Login(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  C_Login(const C_Login& from);
  C_Login(C_Login&& from) noexcept
    : C_Login() {
    *this = ::std::move(from);
  }

  inline C_Login& operator=(const C_Login& from) {
    CopyFrom(from);
    return *this;
  }
  inline C_Login& operator=(C_Login&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const C_Login& default_instance() {
    return *internal_default_instance();
  }
  static inline const C_Login* internal_default_instance() {
    return reinterpret_cast<const C_Login*>(
               &_C_Login_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    30;

  friend void swap(C_Login& a, C_Login& b) {
    a.Swap(&b);
  }
  inline void Swap(C_Login* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(C_Login* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  C_Login* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<C_Login>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const C_Login& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const C_Login& from) {
    C_Login::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(C_Login* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.C_Login";
  }
  protected:
  explicit C_Login(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUsernameFieldNumber = 1,
  };
  // string username = 1;
  void clear_username();
  const std::string& username() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_username(ArgT0&& arg0, ArgT... args);
  std::string* mutable_username();
  PROTOBUF_NODISCARD std::string* release_username();
  void set_allocated_username(std::string* username);
  private:
  const std::string& _internal_username() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_username(const std::string& value);
  std::string* _internal_mutable_username();
  public:

  // @@protoc_insertion_point(class_scope:Protocol.C_Login)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr username_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Protocol_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// S_TEST

// uint64 id = 1;
inline void S_TEST::clear_id() {
  _impl_.id_ = uint64_t{0u};
}
inline uint64_t S_TEST::_internal_id() const {
  return _impl_.id_;
}
inline uint64_t S_TEST::id() const {
  // @@protoc_insertion_point(field_get:Protocol.S_TEST.id)
  return _internal_id();
}
inline void S_TEST::_internal_set_id(uint64_t value) {
  
  _impl_.id_ = value;
}
inline void S_TEST::set_id(uint64_t value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:Protocol.S_TEST.id)
}

// uint32 hp = 2;
inline void S_TEST::clear_hp() {
  _impl_.hp_ = 0u;
}
inline uint32_t S_TEST::_internal_hp() const {
  return _impl_.hp_;
}
inline uint32_t S_TEST::hp() const {
  // @@protoc_insertion_point(field_get:Protocol.S_TEST.hp)
  return _internal_hp();
}
inline void S_TEST::_internal_set_hp(uint32_t value) {
  
  _impl_.hp_ = value;
}
inline void S_TEST::set_hp(uint32_t value) {
  _internal_set_hp(value);
  // @@protoc_insertion_point(field_set:Protocol.S_TEST.hp)
}

// uint32 attack = 3;
inline void S_TEST::clear_attack() {
  _impl_.attack_ = 0u;
}
inline uint32_t S_TEST::_internal_attack() const {
  return _impl_.attack_;
}
inline uint32_t S_TEST::attack() const {
  // @@protoc_insertion_point(field_get:Protocol.S_TEST.attack)
  return _internal_attack();
}
inline void S_TEST::_internal_set_attack(uint32_t value) {
  
  _impl_.attack_ = value;
}
inline void S_TEST::set_attack(uint32_t value) {
  _internal_set_attack(value);
  // @@protoc_insertion_point(field_set:Protocol.S_TEST.attack)
}

// repeated .Protocol.BuffData buffs = 4;
inline int S_TEST::_internal_buffs_size() const {
  return _impl_.buffs_.size();
}
inline int S_TEST::buffs_size() const {
  return _internal_buffs_size();
}
inline ::Protocol::BuffData* S_TEST::mutable_buffs(int index) {
  // @@protoc_insertion_point(field_mutable:Protocol.S_TEST.buffs)
  return _impl_.buffs_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Protocol::BuffData >*
S_TEST::mutable_buffs() {
  // @@protoc_insertion_point(field_mutable_list:Protocol.S_TEST.buffs)
  return &_impl_.buffs_;
}
inline const ::Protocol::BuffData& S_TEST::_internal_buffs(int index) const {
  return _impl_.buffs_.Get(index);
}
inline const ::Protocol::BuffData& S_TEST::buffs(int index) const {
  // @@protoc_insertion_point(field_get:Protocol.S_TEST.buffs)
  return _internal_buffs(index);
}
inline ::Protocol::BuffData* S_TEST::_internal_add_buffs() {
  return _impl_.buffs_.Add();
}
inline ::Protocol::BuffData* S_TEST::add_buffs() {
  ::Protocol::BuffData* _add = _internal_add_buffs();
  // @@protoc_insertion_point(field_add:Protocol.S_TEST.buffs)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Protocol::BuffData >&
S_TEST::buffs() const {
  // @@protoc_insertion_point(field_list:Protocol.S_TEST.buffs)
  return _impl_.buffs_;
}

// -------------------------------------------------------------------

// S_EnterGame

// bool success = 1;
inline void S_EnterGame::clear_success() {
  _impl_.success_ = false;
}
inline bool S_EnterGame::_internal_success() const {
  return _impl_.success_;
}
inline bool S_EnterGame::success() const {
  // @@protoc_insertion_point(field_get:Protocol.S_EnterGame.success)
  return _internal_success();
}
inline void S_EnterGame::_internal_set_success(bool value) {
  
  _impl_.success_ = value;
}
inline void S_EnterGame::set_success(bool value) {
  _internal_set_success(value);
  // @@protoc_insertion_point(field_set:Protocol.S_EnterGame.success)
}

// uint64 accountId = 2;
inline void S_EnterGame::clear_accountid() {
  _impl_.accountid_ = uint64_t{0u};
}
inline uint64_t S_EnterGame::_internal_accountid() const {
  return _impl_.accountid_;
}
inline uint64_t S_EnterGame::accountid() const {
  // @@protoc_insertion_point(field_get:Protocol.S_EnterGame.accountId)
  return _internal_accountid();
}
inline void S_EnterGame::_internal_set_accountid(uint64_t value) {
  
  _impl_.accountid_ = value;
}
inline void S_EnterGame::set_accountid(uint64_t value) {
  _internal_set_accountid(value);
  // @@protoc_insertion_point(field_set:Protocol.S_EnterGame.accountId)
}

// -------------------------------------------------------------------

// S_MyPlayer

// .Protocol.ObjectInfo info = 1;
inline bool S_MyPlayer::_internal_has_info() const {
  return this != internal_default_instance() && _impl_.info_ != nullptr;
}
inline bool S_MyPlayer::has_info() const {
  return _internal_has_info();
}
inline const ::Protocol::ObjectInfo& S_MyPlayer::_internal_info() const {
  const ::Protocol::ObjectInfo* p = _impl_.info_;
  return p != nullptr ? *p : reinterpret_cast<const ::Protocol::ObjectInfo&>(
      ::Protocol::_ObjectInfo_default_instance_);
}
inline const ::Protocol::ObjectInfo& S_MyPlayer::info() const {
  // @@protoc_insertion_point(field_get:Protocol.S_MyPlayer.info)
  return _internal_info();
}
inline void S_MyPlayer::unsafe_arena_set_allocated_info(
    ::Protocol::ObjectInfo* info) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.info_);
  }
  _impl_.info_ = info;
  if (info) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Protocol.S_MyPlayer.info)
}
inline ::Protocol::ObjectInfo* S_MyPlayer::release_info() {
  
  ::Protocol::ObjectInfo* temp = _impl_.info_;
  _impl_.info_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::Protocol::ObjectInfo* S_MyPlayer::unsafe_arena_release_info() {
  // @@protoc_insertion_point(field_release:Protocol.S_MyPlayer.info)
  
  ::Protocol::ObjectInfo* temp = _impl_.info_;
  _impl_.info_ = nullptr;
  return temp;
}
inline ::Protocol::ObjectInfo* S_MyPlayer::_internal_mutable_info() {
  
  if (_impl_.info_ == nullptr) {
    auto* p = CreateMaybeMessage<::Protocol::ObjectInfo>(GetArenaForAllocation());
    _impl_.info_ = p;
  }
  return _impl_.info_;
}
inline ::Protocol::ObjectInfo* S_MyPlayer::mutable_info() {
  ::Protocol::ObjectInfo* _msg = _internal_mutable_info();
  // @@protoc_insertion_point(field_mutable:Protocol.S_MyPlayer.info)
  return _msg;
}
inline void S_MyPlayer::set_allocated_info(::Protocol::ObjectInfo* info) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.info_);
  }
  if (info) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(info));
    if (message_arena != submessage_arena) {
      info = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, info, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.info_ = info;
  // @@protoc_insertion_point(field_set_allocated:Protocol.S_MyPlayer.info)
}

// -------------------------------------------------------------------

// S_AddObject

// repeated .Protocol.ObjectInfo objects = 1;
inline int S_AddObject::_internal_objects_size() const {
  return _impl_.objects_.size();
}
inline int S_AddObject::objects_size() const {
  return _internal_objects_size();
}
inline ::Protocol::ObjectInfo* S_AddObject::mutable_objects(int index) {
  // @@protoc_insertion_point(field_mutable:Protocol.S_AddObject.objects)
  return _impl_.objects_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Protocol::ObjectInfo >*
S_AddObject::mutable_objects() {
  // @@protoc_insertion_point(field_mutable_list:Protocol.S_AddObject.objects)
  return &_impl_.objects_;
}
inline const ::Protocol::ObjectInfo& S_AddObject::_internal_objects(int index) const {
  return _impl_.objects_.Get(index);
}
inline const ::Protocol::ObjectInfo& S_AddObject::objects(int index) const {
  // @@protoc_insertion_point(field_get:Protocol.S_AddObject.objects)
  return _internal_objects(index);
}
inline ::Protocol::ObjectInfo* S_AddObject::_internal_add_objects() {
  return _impl_.objects_.Add();
}
inline ::Protocol::ObjectInfo* S_AddObject::add_objects() {
  ::Protocol::ObjectInfo* _add = _internal_add_objects();
  // @@protoc_insertion_point(field_add:Protocol.S_AddObject.objects)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Protocol::ObjectInfo >&
S_AddObject::objects() const {
  // @@protoc_insertion_point(field_list:Protocol.S_AddObject.objects)
  return _impl_.objects_;
}

// -------------------------------------------------------------------

// S_RemoveObject

// repeated uint64 ids = 1;
inline int S_RemoveObject::_internal_ids_size() const {
  return _impl_.ids_.size();
}
inline int S_RemoveObject::ids_size() const {
  return _internal_ids_size();
}
inline void S_RemoveObject::clear_ids() {
  _impl_.ids_.Clear();
}
inline uint64_t S_RemoveObject::_internal_ids(int index) const {
  return _impl_.ids_.Get(index);
}
inline uint64_t S_RemoveObject::ids(int index) const {
  // @@protoc_insertion_point(field_get:Protocol.S_RemoveObject.ids)
  return _internal_ids(index);
}
inline void S_RemoveObject::set_ids(int index, uint64_t value) {
  _impl_.ids_.Set(index, value);
  // @@protoc_insertion_point(field_set:Protocol.S_RemoveObject.ids)
}
inline void S_RemoveObject::_internal_add_ids(uint64_t value) {
  _impl_.ids_.Add(value);
}
inline void S_RemoveObject::add_ids(uint64_t value) {
  _internal_add_ids(value);
  // @@protoc_insertion_point(field_add:Protocol.S_RemoveObject.ids)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
S_RemoveObject::_internal_ids() const {
  return _impl_.ids_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
S_RemoveObject::ids() const {
  // @@protoc_insertion_point(field_list:Protocol.S_RemoveObject.ids)
  return _internal_ids();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
S_RemoveObject::_internal_mutable_ids() {
  return &_impl_.ids_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
S_RemoveObject::mutable_ids() {
  // @@protoc_insertion_point(field_mutable_list:Protocol.S_RemoveObject.ids)
  return _internal_mutable_ids();
}

// -------------------------------------------------------------------

// C_Move

// .Protocol.DIR_TYPE dir = 1;
inline void C_Move::clear_dir() {
  _impl_.dir_ = 0;
}
inline ::Protocol::DIR_TYPE C_Move::_internal_dir() const {
  return static_cast< ::Protocol::DIR_TYPE >(_impl_.dir_);
}
inline ::Protocol::DIR_TYPE C_Move::dir() const {
  // @@protoc_insertion_point(field_get:Protocol.C_Move.dir)
  return _internal_dir();
}
inline void C_Move::_internal_set_dir(::Protocol::DIR_TYPE value) {
  
  _impl_.dir_ = value;
}
inline void C_Move::set_dir(::Protocol::DIR_TYPE value) {
  _internal_set_dir(value);
  // @@protoc_insertion_point(field_set:Protocol.C_Move.dir)
}

// -------------------------------------------------------------------

// S_Move

// .Protocol.ObjectInfo info = 1;
inline bool S_Move::_internal_has_info() const {
  return this != internal_default_instance() && _impl_.info_ != nullptr;
}
inline bool S_Move::has_info() const {
  return _internal_has_info();
}
inline const ::Protocol::ObjectInfo& S_Move::_internal_info() const {
  const ::Protocol::ObjectInfo* p = _impl_.info_;
  return p != nullptr ? *p : reinterpret_cast<const ::Protocol::ObjectInfo&>(
      ::Protocol::_ObjectInfo_default_instance_);
}
inline const ::Protocol::ObjectInfo& S_Move::info() const {
  // @@protoc_insertion_point(field_get:Protocol.S_Move.info)
  return _internal_info();
}
inline void S_Move::unsafe_arena_set_allocated_info(
    ::Protocol::ObjectInfo* info) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.info_);
  }
  _impl_.info_ = info;
  if (info) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Protocol.S_Move.info)
}
inline ::Protocol::ObjectInfo* S_Move::release_info() {
  
  ::Protocol::ObjectInfo* temp = _impl_.info_;
  _impl_.info_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::Protocol::ObjectInfo* S_Move::unsafe_arena_release_info() {
  // @@protoc_insertion_point(field_release:Protocol.S_Move.info)
  
  ::Protocol::ObjectInfo* temp = _impl_.info_;
  _impl_.info_ = nullptr;
  return temp;
}
inline ::Protocol::ObjectInfo* S_Move::_internal_mutable_info() {
  
  if (_impl_.info_ == nullptr) {
    auto* p = CreateMaybeMessage<::Protocol::ObjectInfo>(GetArenaForAllocation());
    _impl_.info_ = p;
  }
  return _impl_.info_;
}
inline ::Protocol::ObjectInfo* S_Move::mutable_info() {
  ::Protocol::ObjectInfo* _msg = _internal_mutable_info();
  // @@protoc_insertion_point(field_mutable:Protocol.S_Move.info)
  return _msg;
}
inline void S_Move::set_allocated_info(::Protocol::ObjectInfo* info) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.info_);
  }
  if (info) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(info));
    if (message_arena != submessage_arena) {
      info = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, info, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.info_ = info;
  // @@protoc_insertion_point(field_set_allocated:Protocol.S_Move.info)
}

// -------------------------------------------------------------------

// C_Turn

// .Protocol.DIR_TYPE dir = 1;
inline void C_Turn::clear_dir() {
  _impl_.dir_ = 0;
}
inline ::Protocol::DIR_TYPE C_Turn::_internal_dir() const {
  return static_cast< ::Protocol::DIR_TYPE >(_impl_.dir_);
}
inline ::Protocol::DIR_TYPE C_Turn::dir() const {
  // @@protoc_insertion_point(field_get:Protocol.C_Turn.dir)
  return _internal_dir();
}
inline void C_Turn::_internal_set_dir(::Protocol::DIR_TYPE value) {
  
  _impl_.dir_ = value;
}
inline void C_Turn::set_dir(::Protocol::DIR_TYPE value) {
  _internal_set_dir(value);
  // @@protoc_insertion_point(field_set:Protocol.C_Turn.dir)
}

// -------------------------------------------------------------------

// S_Turn

// .Protocol.ObjectInfo info = 1;
inline bool S_Turn::_internal_has_info() const {
  return this != internal_default_instance() && _impl_.info_ != nullptr;
}
inline bool S_Turn::has_info() const {
  return _internal_has_info();
}
inline const ::Protocol::ObjectInfo& S_Turn::_internal_info() const {
  const ::Protocol::ObjectInfo* p = _impl_.info_;
  return p != nullptr ? *p : reinterpret_cast<const ::Protocol::ObjectInfo&>(
      ::Protocol::_ObjectInfo_default_instance_);
}
inline const ::Protocol::ObjectInfo& S_Turn::info() const {
  // @@protoc_insertion_point(field_get:Protocol.S_Turn.info)
  return _internal_info();
}
inline void S_Turn::unsafe_arena_set_allocated_info(
    ::Protocol::ObjectInfo* info) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.info_);
  }
  _impl_.info_ = info;
  if (info) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Protocol.S_Turn.info)
}
inline ::Protocol::ObjectInfo* S_Turn::release_info() {
  
  ::Protocol::ObjectInfo* temp = _impl_.info_;
  _impl_.info_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::Protocol::ObjectInfo* S_Turn::unsafe_arena_release_info() {
  // @@protoc_insertion_point(field_release:Protocol.S_Turn.info)
  
  ::Protocol::ObjectInfo* temp = _impl_.info_;
  _impl_.info_ = nullptr;
  return temp;
}
inline ::Protocol::ObjectInfo* S_Turn::_internal_mutable_info() {
  
  if (_impl_.info_ == nullptr) {
    auto* p = CreateMaybeMessage<::Protocol::ObjectInfo>(GetArenaForAllocation());
    _impl_.info_ = p;
  }
  return _impl_.info_;
}
inline ::Protocol::ObjectInfo* S_Turn::mutable_info() {
  ::Protocol::ObjectInfo* _msg = _internal_mutable_info();
  // @@protoc_insertion_point(field_mutable:Protocol.S_Turn.info)
  return _msg;
}
inline void S_Turn::set_allocated_info(::Protocol::ObjectInfo* info) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.info_);
  }
  if (info) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(info));
    if (message_arena != submessage_arena) {
      info = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, info, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.info_ = info;
  // @@protoc_insertion_point(field_set_allocated:Protocol.S_Turn.info)
}

// -------------------------------------------------------------------

// C_Attack

// .Protocol.DIR_TYPE dir = 1;
inline void C_Attack::clear_dir() {
  _impl_.dir_ = 0;
}
inline ::Protocol::DIR_TYPE C_Attack::_internal_dir() const {
  return static_cast< ::Protocol::DIR_TYPE >(_impl_.dir_);
}
inline ::Protocol::DIR_TYPE C_Attack::dir() const {
  // @@protoc_insertion_point(field_get:Protocol.C_Attack.dir)
  return _internal_dir();
}
inline void C_Attack::_internal_set_dir(::Protocol::DIR_TYPE value) {
  
  _impl_.dir_ = value;
}
inline void C_Attack::set_dir(::Protocol::DIR_TYPE value) {
  _internal_set_dir(value);
  // @@protoc_insertion_point(field_set:Protocol.C_Attack.dir)
}

// .Protocol.WEAPON_TYPE weaponType = 2;
inline void C_Attack::clear_weapontype() {
  _impl_.weapontype_ = 0;
}
inline ::Protocol::WEAPON_TYPE C_Attack::_internal_weapontype() const {
  return static_cast< ::Protocol::WEAPON_TYPE >(_impl_.weapontype_);
}
inline ::Protocol::WEAPON_TYPE C_Attack::weapontype() const {
  // @@protoc_insertion_point(field_get:Protocol.C_Attack.weaponType)
  return _internal_weapontype();
}
inline void C_Attack::_internal_set_weapontype(::Protocol::WEAPON_TYPE value) {
  
  _impl_.weapontype_ = value;
}
inline void C_Attack::set_weapontype(::Protocol::WEAPON_TYPE value) {
  _internal_set_weapontype(value);
  // @@protoc_insertion_point(field_set:Protocol.C_Attack.weaponType)
}

// -------------------------------------------------------------------

// S_Attack

// uint64 attackerId = 1;
inline void S_Attack::clear_attackerid() {
  _impl_.attackerid_ = uint64_t{0u};
}
inline uint64_t S_Attack::_internal_attackerid() const {
  return _impl_.attackerid_;
}
inline uint64_t S_Attack::attackerid() const {
  // @@protoc_insertion_point(field_get:Protocol.S_Attack.attackerId)
  return _internal_attackerid();
}
inline void S_Attack::_internal_set_attackerid(uint64_t value) {
  
  _impl_.attackerid_ = value;
}
inline void S_Attack::set_attackerid(uint64_t value) {
  _internal_set_attackerid(value);
  // @@protoc_insertion_point(field_set:Protocol.S_Attack.attackerId)
}

// .Protocol.DIR_TYPE dir = 2;
inline void S_Attack::clear_dir() {
  _impl_.dir_ = 0;
}
inline ::Protocol::DIR_TYPE S_Attack::_internal_dir() const {
  return static_cast< ::Protocol::DIR_TYPE >(_impl_.dir_);
}
inline ::Protocol::DIR_TYPE S_Attack::dir() const {
  // @@protoc_insertion_point(field_get:Protocol.S_Attack.dir)
  return _internal_dir();
}
inline void S_Attack::_internal_set_dir(::Protocol::DIR_TYPE value) {
  
  _impl_.dir_ = value;
}
inline void S_Attack::set_dir(::Protocol::DIR_TYPE value) {
  _internal_set_dir(value);
  // @@protoc_insertion_point(field_set:Protocol.S_Attack.dir)
}

// .Protocol.WEAPON_TYPE weaponType = 3;
inline void S_Attack::clear_weapontype() {
  _impl_.weapontype_ = 0;
}
inline ::Protocol::WEAPON_TYPE S_Attack::_internal_weapontype() const {
  return static_cast< ::Protocol::WEAPON_TYPE >(_impl_.weapontype_);
}
inline ::Protocol::WEAPON_TYPE S_Attack::weapontype() const {
  // @@protoc_insertion_point(field_get:Protocol.S_Attack.weaponType)
  return _internal_weapontype();
}
inline void S_Attack::_internal_set_weapontype(::Protocol::WEAPON_TYPE value) {
  
  _impl_.weapontype_ = value;
}
inline void S_Attack::set_weapontype(::Protocol::WEAPON_TYPE value) {
  _internal_set_weapontype(value);
  // @@protoc_insertion_point(field_set:Protocol.S_Attack.weaponType)
}

// -------------------------------------------------------------------

// S_Damaged

// uint64 attackerId = 1;
inline void S_Damaged::clear_attackerid() {
  _impl_.attackerid_ = uint64_t{0u};
}
inline uint64_t S_Damaged::_internal_attackerid() const {
  return _impl_.attackerid_;
}
inline uint64_t S_Damaged::attackerid() const {
  // @@protoc_insertion_point(field_get:Protocol.S_Damaged.attackerId)
  return _internal_attackerid();
}
inline void S_Damaged::_internal_set_attackerid(uint64_t value) {
  
  _impl_.attackerid_ = value;
}
inline void S_Damaged::set_attackerid(uint64_t value) {
  _internal_set_attackerid(value);
  // @@protoc_insertion_point(field_set:Protocol.S_Damaged.attackerId)
}

// uint64 targetId = 2;
inline void S_Damaged::clear_targetid() {
  _impl_.targetid_ = uint64_t{0u};
}
inline uint64_t S_Damaged::_internal_targetid() const {
  return _impl_.targetid_;
}
inline uint64_t S_Damaged::targetid() const {
  // @@protoc_insertion_point(field_get:Protocol.S_Damaged.targetId)
  return _internal_targetid();
}
inline void S_Damaged::_internal_set_targetid(uint64_t value) {
  
  _impl_.targetid_ = value;
}
inline void S_Damaged::set_targetid(uint64_t value) {
  _internal_set_targetid(value);
  // @@protoc_insertion_point(field_set:Protocol.S_Damaged.targetId)
}

// int32 newHp = 3;
inline void S_Damaged::clear_newhp() {
  _impl_.newhp_ = 0;
}
inline int32_t S_Damaged::_internal_newhp() const {
  return _impl_.newhp_;
}
inline int32_t S_Damaged::newhp() const {
  // @@protoc_insertion_point(field_get:Protocol.S_Damaged.newHp)
  return _internal_newhp();
}
inline void S_Damaged::_internal_set_newhp(int32_t value) {
  
  _impl_.newhp_ = value;
}
inline void S_Damaged::set_newhp(int32_t value) {
  _internal_set_newhp(value);
  // @@protoc_insertion_point(field_set:Protocol.S_Damaged.newHp)
}

// int32 damage = 4;
inline void S_Damaged::clear_damage() {
  _impl_.damage_ = 0;
}
inline int32_t S_Damaged::_internal_damage() const {
  return _impl_.damage_;
}
inline int32_t S_Damaged::damage() const {
  // @@protoc_insertion_point(field_get:Protocol.S_Damaged.damage)
  return _internal_damage();
}
inline void S_Damaged::_internal_set_damage(int32_t value) {
  
  _impl_.damage_ = value;
}
inline void S_Damaged::set_damage(int32_t value) {
  _internal_set_damage(value);
  // @@protoc_insertion_point(field_set:Protocol.S_Damaged.damage)
}

// -------------------------------------------------------------------

// C_ChangeMap

// .Protocol.MAP_ID mapId = 1;
inline void C_ChangeMap::clear_mapid() {
  _impl_.mapid_ = 0;
}
inline ::Protocol::MAP_ID C_ChangeMap::_internal_mapid() const {
  return static_cast< ::Protocol::MAP_ID >(_impl_.mapid_);
}
inline ::Protocol::MAP_ID C_ChangeMap::mapid() const {
  // @@protoc_insertion_point(field_get:Protocol.C_ChangeMap.mapId)
  return _internal_mapid();
}
inline void C_ChangeMap::_internal_set_mapid(::Protocol::MAP_ID value) {
  
  _impl_.mapid_ = value;
}
inline void C_ChangeMap::set_mapid(::Protocol::MAP_ID value) {
  _internal_set_mapid(value);
  // @@protoc_insertion_point(field_set:Protocol.C_ChangeMap.mapId)
}

// int32 channel = 2;
inline void C_ChangeMap::clear_channel() {
  _impl_.channel_ = 0;
}
inline int32_t C_ChangeMap::_internal_channel() const {
  return _impl_.channel_;
}
inline int32_t C_ChangeMap::channel() const {
  // @@protoc_insertion_point(field_get:Protocol.C_ChangeMap.channel)
  return _internal_channel();
}
inline void C_ChangeMap::_internal_set_channel(int32_t value) {
  
  _impl_.channel_ = value;
}
inline void C_ChangeMap::set_channel(int32_t value) {
  _internal_set_channel(value);
  // @@protoc_insertion_point(field_set:Protocol.C_ChangeMap.channel)
}

// -------------------------------------------------------------------

// S_ChangeMap

// bool success = 1;
inline void S_ChangeMap::clear_success() {
  _impl_.success_ = false;
}
inline bool S_ChangeMap::_internal_success() const {
  return _impl_.success_;
}
inline bool S_ChangeMap::success() const {
  // @@protoc_insertion_point(field_get:Protocol.S_ChangeMap.success)
  return _internal_success();
}
inline void S_ChangeMap::_internal_set_success(bool value) {
  
  _impl_.success_ = value;
}
inline void S_ChangeMap::set_success(bool value) {
  _internal_set_success(value);
  // @@protoc_insertion_point(field_set:Protocol.S_ChangeMap.success)
}

// .Protocol.MAP_ID mapId = 2;
inline void S_ChangeMap::clear_mapid() {
  _impl_.mapid_ = 0;
}
inline ::Protocol::MAP_ID S_ChangeMap::_internal_mapid() const {
  return static_cast< ::Protocol::MAP_ID >(_impl_.mapid_);
}
inline ::Protocol::MAP_ID S_ChangeMap::mapid() const {
  // @@protoc_insertion_point(field_get:Protocol.S_ChangeMap.mapId)
  return _internal_mapid();
}
inline void S_ChangeMap::_internal_set_mapid(::Protocol::MAP_ID value) {
  
  _impl_.mapid_ = value;
}
inline void S_ChangeMap::set_mapid(::Protocol::MAP_ID value) {
  _internal_set_mapid(value);
  // @@protoc_insertion_point(field_set:Protocol.S_ChangeMap.mapId)
}

// int32 channel = 3;
inline void S_ChangeMap::clear_channel() {
  _impl_.channel_ = 0;
}
inline int32_t S_ChangeMap::_internal_channel() const {
  return _impl_.channel_;
}
inline int32_t S_ChangeMap::channel() const {
  // @@protoc_insertion_point(field_get:Protocol.S_ChangeMap.channel)
  return _internal_channel();
}
inline void S_ChangeMap::_internal_set_channel(int32_t value) {
  
  _impl_.channel_ = value;
}
inline void S_ChangeMap::set_channel(int32_t value) {
  _internal_set_channel(value);
  // @@protoc_insertion_point(field_set:Protocol.S_ChangeMap.channel)
}

// uint64 instanceId = 4;
inline void S_ChangeMap::clear_instanceid() {
  _impl_.instanceid_ = uint64_t{0u};
}
inline uint64_t S_ChangeMap::_internal_instanceid() const {
  return _impl_.instanceid_;
}
inline uint64_t S_ChangeMap::instanceid() const {
  // @@protoc_insertion_point(field_get:Protocol.S_ChangeMap.instanceId)
  return _internal_instanceid();
}
inline void S_ChangeMap::_internal_set_instanceid(uint64_t value) {
  
  _impl_.instanceid_ = value;
}
inline void S_ChangeMap::set_instanceid(uint64_t value) {
  _internal_set_instanceid(value);
  // @@protoc_insertion_point(field_set:Protocol.S_ChangeMap.instanceId)
}

// -------------------------------------------------------------------

// S_GainExp

// uint64 playerId = 1;
inline void S_GainExp::clear_playerid() {
  _impl_.playerid_ = uint64_t{0u};
}
inline uint64_t S_GainExp::_internal_playerid() const {
  return _impl_.playerid_;
}
inline uint64_t S_GainExp::playerid() const {
  // @@protoc_insertion_point(field_get:Protocol.S_GainExp.playerId)
  return _internal_playerid();
}
inline void S_GainExp::_internal_set_playerid(uint64_t value) {
  
  _impl_.playerid_ = value;
}
inline void S_GainExp::set_playerid(uint64_t value) {
  _internal_set_playerid(value);
  // @@protoc_insertion_point(field_set:Protocol.S_GainExp.playerId)
}

// int32 gainedExp = 2;
inline void S_GainExp::clear_gainedexp() {
  _impl_.gainedexp_ = 0;
}
inline int32_t S_GainExp::_internal_gainedexp() const {
  return _impl_.gainedexp_;
}
inline int32_t S_GainExp::gainedexp() const {
  // @@protoc_insertion_point(field_get:Protocol.S_GainExp.gainedExp)
  return _internal_gainedexp();
}
inline void S_GainExp::_internal_set_gainedexp(int32_t value) {
  
  _impl_.gainedexp_ = value;
}
inline void S_GainExp::set_gainedexp(int32_t value) {
  _internal_set_gainedexp(value);
  // @@protoc_insertion_point(field_set:Protocol.S_GainExp.gainedExp)
}

// int32 currentExp = 3;
inline void S_GainExp::clear_currentexp() {
  _impl_.currentexp_ = 0;
}
inline int32_t S_GainExp::_internal_currentexp() const {
  return _impl_.currentexp_;
}
inline int32_t S_GainExp::currentexp() const {
  // @@protoc_insertion_point(field_get:Protocol.S_GainExp.currentExp)
  return _internal_currentexp();
}
inline void S_GainExp::_internal_set_currentexp(int32_t value) {
  
  _impl_.currentexp_ = value;
}
inline void S_GainExp::set_currentexp(int32_t value) {
  _internal_set_currentexp(value);
  // @@protoc_insertion_point(field_set:Protocol.S_GainExp.currentExp)
}

// int32 maxExp = 4;
inline void S_GainExp::clear_maxexp() {
  _impl_.maxexp_ = 0;
}
inline int32_t S_GainExp::_internal_maxexp() const {
  return _impl_.maxexp_;
}
inline int32_t S_GainExp::maxexp() const {
  // @@protoc_insertion_point(field_get:Protocol.S_GainExp.maxExp)
  return _internal_maxexp();
}
inline void S_GainExp::_internal_set_maxexp(int32_t value) {
  
  _impl_.maxexp_ = value;
}
inline void S_GainExp::set_maxexp(int32_t value) {
  _internal_set_maxexp(value);
  // @@protoc_insertion_point(field_set:Protocol.S_GainExp.maxExp)
}

// -------------------------------------------------------------------

// S_LevelUp

// uint64 playerId = 1;
inline void S_LevelUp::clear_playerid() {
  _impl_.playerid_ = uint64_t{0u};
}
inline uint64_t S_LevelUp::_internal_playerid() const {
  return _impl_.playerid_;
}
inline uint64_t S_LevelUp::playerid() const {
  // @@protoc_insertion_point(field_get:Protocol.S_LevelUp.playerId)
  return _internal_playerid();
}
inline void S_LevelUp::_internal_set_playerid(uint64_t value) {
  
  _impl_.playerid_ = value;
}
inline void S_LevelUp::set_playerid(uint64_t value) {
  _internal_set_playerid(value);
  // @@protoc_insertion_point(field_set:Protocol.S_LevelUp.playerId)
}

// int32 newLevel = 2;
inline void S_LevelUp::clear_newlevel() {
  _impl_.newlevel_ = 0;
}
inline int32_t S_LevelUp::_internal_newlevel() const {
  return _impl_.newlevel_;
}
inline int32_t S_LevelUp::newlevel() const {
  // @@protoc_insertion_point(field_get:Protocol.S_LevelUp.newLevel)
  return _internal_newlevel();
}
inline void S_LevelUp::_internal_set_newlevel(int32_t value) {
  
  _impl_.newlevel_ = value;
}
inline void S_LevelUp::set_newlevel(int32_t value) {
  _internal_set_newlevel(value);
  // @@protoc_insertion_point(field_set:Protocol.S_LevelUp.newLevel)
}

// int32 maxHp = 3;
inline void S_LevelUp::clear_maxhp() {
  _impl_.maxhp_ = 0;
}
inline int32_t S_LevelUp::_internal_maxhp() const {
  return _impl_.maxhp_;
}
inline int32_t S_LevelUp::maxhp() const {
  // @@protoc_insertion_point(field_get:Protocol.S_LevelUp.maxHp)
  return _internal_maxhp();
}
inline void S_LevelUp::_internal_set_maxhp(int32_t value) {
  
  _impl_.maxhp_ = value;
}
inline void S_LevelUp::set_maxhp(int32_t value) {
  _internal_set_maxhp(value);
  // @@protoc_insertion_point(field_set:Protocol.S_LevelUp.maxHp)
}

// int32 attack = 4;
inline void S_LevelUp::clear_attack() {
  _impl_.attack_ = 0;
}
inline int32_t S_LevelUp::_internal_attack() const {
  return _impl_.attack_;
}
inline int32_t S_LevelUp::attack() const {
  // @@protoc_insertion_point(field_get:Protocol.S_LevelUp.attack)
  return _internal_attack();
}
inline void S_LevelUp::_internal_set_attack(int32_t value) {
  
  _impl_.attack_ = value;
}
inline void S_LevelUp::set_attack(int32_t value) {
  _internal_set_attack(value);
  // @@protoc_insertion_point(field_set:Protocol.S_LevelUp.attack)
}

// int32 defence = 5;
inline void S_LevelUp::clear_defence() {
  _impl_.defence_ = 0;
}
inline int32_t S_LevelUp::_internal_defence() const {
  return _impl_.defence_;
}
inline int32_t S_LevelUp::defence() const {
  // @@protoc_insertion_point(field_get:Protocol.S_LevelUp.defence)
  return _internal_defence();
}
inline void S_LevelUp::_internal_set_defence(int32_t value) {
  
  _impl_.defence_ = value;
}
inline void S_LevelUp::set_defence(int32_t value) {
  _internal_set_defence(value);
  // @@protoc_insertion_point(field_set:Protocol.S_LevelUp.defence)
}

// int32 maxExp = 6;
inline void S_LevelUp::clear_maxexp() {
  _impl_.maxexp_ = 0;
}
inline int32_t S_LevelUp::_internal_maxexp() const {
  return _impl_.maxexp_;
}
inline int32_t S_LevelUp::maxexp() const {
  // @@protoc_insertion_point(field_get:Protocol.S_LevelUp.maxExp)
  return _internal_maxexp();
}
inline void S_LevelUp::_internal_set_maxexp(int32_t value) {
  
  _impl_.maxexp_ = value;
}
inline void S_LevelUp::set_maxexp(int32_t value) {
  _internal_set_maxexp(value);
  // @@protoc_insertion_point(field_set:Protocol.S_LevelUp.maxExp)
}

// -------------------------------------------------------------------

// S_InventoryData

// repeated .Protocol.ItemInfo items = 1;
inline int S_InventoryData::_internal_items_size() const {
  return _impl_.items_.size();
}
inline int S_InventoryData::items_size() const {
  return _internal_items_size();
}
inline ::Protocol::ItemInfo* S_InventoryData::mutable_items(int index) {
  // @@protoc_insertion_point(field_mutable:Protocol.S_InventoryData.items)
  return _impl_.items_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Protocol::ItemInfo >*
S_InventoryData::mutable_items() {
  // @@protoc_insertion_point(field_mutable_list:Protocol.S_InventoryData.items)
  return &_impl_.items_;
}
inline const ::Protocol::ItemInfo& S_InventoryData::_internal_items(int index) const {
  return _impl_.items_.Get(index);
}
inline const ::Protocol::ItemInfo& S_InventoryData::items(int index) const {
  // @@protoc_insertion_point(field_get:Protocol.S_InventoryData.items)
  return _internal_items(index);
}
inline ::Protocol::ItemInfo* S_InventoryData::_internal_add_items() {
  return _impl_.items_.Add();
}
inline ::Protocol::ItemInfo* S_InventoryData::add_items() {
  ::Protocol::ItemInfo* _add = _internal_add_items();
  // @@protoc_insertion_point(field_add:Protocol.S_InventoryData.items)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Protocol::ItemInfo >&
S_InventoryData::items() const {
  // @@protoc_insertion_point(field_list:Protocol.S_InventoryData.items)
  return _impl_.items_;
}

// .Protocol.ItemInfo equippedWeapon = 2;
inline bool S_InventoryData::_internal_has_equippedweapon() const {
  return this != internal_default_instance() && _impl_.equippedweapon_ != nullptr;
}
inline bool S_InventoryData::has_equippedweapon() const {
  return _internal_has_equippedweapon();
}
inline const ::Protocol::ItemInfo& S_InventoryData::_internal_equippedweapon() const {
  const ::Protocol::ItemInfo* p = _impl_.equippedweapon_;
  return p != nullptr ? *p : reinterpret_cast<const ::Protocol::ItemInfo&>(
      ::Protocol::_ItemInfo_default_instance_);
}
inline const ::Protocol::ItemInfo& S_InventoryData::equippedweapon() const {
  // @@protoc_insertion_point(field_get:Protocol.S_InventoryData.equippedWeapon)
  return _internal_equippedweapon();
}
inline void S_InventoryData::unsafe_arena_set_allocated_equippedweapon(
    ::Protocol::ItemInfo* equippedweapon) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.equippedweapon_);
  }
  _impl_.equippedweapon_ = equippedweapon;
  if (equippedweapon) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Protocol.S_InventoryData.equippedWeapon)
}
inline ::Protocol::ItemInfo* S_InventoryData::release_equippedweapon() {
  
  ::Protocol::ItemInfo* temp = _impl_.equippedweapon_;
  _impl_.equippedweapon_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::Protocol::ItemInfo* S_InventoryData::unsafe_arena_release_equippedweapon() {
  // @@protoc_insertion_point(field_release:Protocol.S_InventoryData.equippedWeapon)
  
  ::Protocol::ItemInfo* temp = _impl_.equippedweapon_;
  _impl_.equippedweapon_ = nullptr;
  return temp;
}
inline ::Protocol::ItemInfo* S_InventoryData::_internal_mutable_equippedweapon() {
  
  if (_impl_.equippedweapon_ == nullptr) {
    auto* p = CreateMaybeMessage<::Protocol::ItemInfo>(GetArenaForAllocation());
    _impl_.equippedweapon_ = p;
  }
  return _impl_.equippedweapon_;
}
inline ::Protocol::ItemInfo* S_InventoryData::mutable_equippedweapon() {
  ::Protocol::ItemInfo* _msg = _internal_mutable_equippedweapon();
  // @@protoc_insertion_point(field_mutable:Protocol.S_InventoryData.equippedWeapon)
  return _msg;
}
inline void S_InventoryData::set_allocated_equippedweapon(::Protocol::ItemInfo* equippedweapon) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.equippedweapon_);
  }
  if (equippedweapon) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(equippedweapon));
    if (message_arena != submessage_arena) {
      equippedweapon = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, equippedweapon, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.equippedweapon_ = equippedweapon;
  // @@protoc_insertion_point(field_set_allocated:Protocol.S_InventoryData.equippedWeapon)
}

// .Protocol.ItemInfo equippedArmor = 3;
inline bool S_InventoryData::_internal_has_equippedarmor() const {
  return this != internal_default_instance() && _impl_.equippedarmor_ != nullptr;
}
inline bool S_InventoryData::has_equippedarmor() const {
  return _internal_has_equippedarmor();
}
inline const ::Protocol::ItemInfo& S_InventoryData::_internal_equippedarmor() const {
  const ::Protocol::ItemInfo* p = _impl_.equippedarmor_;
  return p != nullptr ? *p : reinterpret_cast<const ::Protocol::ItemInfo&>(
      ::Protocol::_ItemInfo_default_instance_);
}
inline const ::Protocol::ItemInfo& S_InventoryData::equippedarmor() const {
  // @@protoc_insertion_point(field_get:Protocol.S_InventoryData.equippedArmor)
  return _internal_equippedarmor();
}
inline void S_InventoryData::unsafe_arena_set_allocated_equippedarmor(
    ::Protocol::ItemInfo* equippedarmor) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.equippedarmor_);
  }
  _impl_.equippedarmor_ = equippedarmor;
  if (equippedarmor) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Protocol.S_InventoryData.equippedArmor)
}
inline ::Protocol::ItemInfo* S_InventoryData::release_equippedarmor() {
  
  ::Protocol::ItemInfo* temp = _impl_.equippedarmor_;
  _impl_.equippedarmor_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::Protocol::ItemInfo* S_InventoryData::unsafe_arena_release_equippedarmor() {
  // @@protoc_insertion_point(field_release:Protocol.S_InventoryData.equippedArmor)
  
  ::Protocol::ItemInfo* temp = _impl_.equippedarmor_;
  _impl_.equippedarmor_ = nullptr;
  return temp;
}
inline ::Protocol::ItemInfo* S_InventoryData::_internal_mutable_equippedarmor() {
  
  if (_impl_.equippedarmor_ == nullptr) {
    auto* p = CreateMaybeMessage<::Protocol::ItemInfo>(GetArenaForAllocation());
    _impl_.equippedarmor_ = p;
  }
  return _impl_.equippedarmor_;
}
inline ::Protocol::ItemInfo* S_InventoryData::mutable_equippedarmor() {
  ::Protocol::ItemInfo* _msg = _internal_mutable_equippedarmor();
  // @@protoc_insertion_point(field_mutable:Protocol.S_InventoryData.equippedArmor)
  return _msg;
}
inline void S_InventoryData::set_allocated_equippedarmor(::Protocol::ItemInfo* equippedarmor) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.equippedarmor_);
  }
  if (equippedarmor) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(equippedarmor));
    if (message_arena != submessage_arena) {
      equippedarmor = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, equippedarmor, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.equippedarmor_ = equippedarmor;
  // @@protoc_insertion_point(field_set_allocated:Protocol.S_InventoryData.equippedArmor)
}

// .Protocol.ItemInfo equippedPotion = 4;
inline bool S_InventoryData::_internal_has_equippedpotion() const {
  return this != internal_default_instance() && _impl_.equippedpotion_ != nullptr;
}
inline bool S_InventoryData::has_equippedpotion() const {
  return _internal_has_equippedpotion();
}
inline const ::Protocol::ItemInfo& S_InventoryData::_internal_equippedpotion() const {
  const ::Protocol::ItemInfo* p = _impl_.equippedpotion_;
  return p != nullptr ? *p : reinterpret_cast<const ::Protocol::ItemInfo&>(
      ::Protocol::_ItemInfo_default_instance_);
}
inline const ::Protocol::ItemInfo& S_InventoryData::equippedpotion() const {
  // @@protoc_insertion_point(field_get:Protocol.S_InventoryData.equippedPotion)
  return _internal_equippedpotion();
}
inline void S_InventoryData::unsafe_arena_set_allocated_equippedpotion(
    ::Protocol::ItemInfo* equippedpotion) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.equippedpotion_);
  }
  _impl_.equippedpotion_ = equippedpotion;
  if (equippedpotion) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Protocol.S_InventoryData.equippedPotion)
}
inline ::Protocol::ItemInfo* S_InventoryData::release_equippedpotion() {
  
  ::Protocol::ItemInfo* temp = _impl_.equippedpotion_;
  _impl_.equippedpotion_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::Protocol::ItemInfo* S_InventoryData::unsafe_arena_release_equippedpotion() {
  // @@protoc_insertion_point(field_release:Protocol.S_InventoryData.equippedPotion)
  
  ::Protocol::ItemInfo* temp = _impl_.equippedpotion_;
  _impl_.equippedpotion_ = nullptr;
  return temp;
}
inline ::Protocol::ItemInfo* S_InventoryData::_internal_mutable_equippedpotion() {
  
  if (_impl_.equippedpotion_ == nullptr) {
    auto* p = CreateMaybeMessage<::Protocol::ItemInfo>(GetArenaForAllocation());
    _impl_.equippedpotion_ = p;
  }
  return _impl_.equippedpotion_;
}
inline ::Protocol::ItemInfo* S_InventoryData::mutable_equippedpotion() {
  ::Protocol::ItemInfo* _msg = _internal_mutable_equippedpotion();
  // @@protoc_insertion_point(field_mutable:Protocol.S_InventoryData.equippedPotion)
  return _msg;
}
inline void S_InventoryData::set_allocated_equippedpotion(::Protocol::ItemInfo* equippedpotion) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.equippedpotion_);
  }
  if (equippedpotion) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(equippedpotion));
    if (message_arena != submessage_arena) {
      equippedpotion = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, equippedpotion, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.equippedpotion_ = equippedpotion;
  // @@protoc_insertion_point(field_set_allocated:Protocol.S_InventoryData.equippedPotion)
}

// -------------------------------------------------------------------

// S_AddItem

// int32 itemId = 1;
inline void S_AddItem::clear_itemid() {
  _impl_.itemid_ = 0;
}
inline int32_t S_AddItem::_internal_itemid() const {
  return _impl_.itemid_;
}
inline int32_t S_AddItem::itemid() const {
  // @@protoc_insertion_point(field_get:Protocol.S_AddItem.itemId)
  return _internal_itemid();
}
inline void S_AddItem::_internal_set_itemid(int32_t value) {
  
  _impl_.itemid_ = value;
}
inline void S_AddItem::set_itemid(int32_t value) {
  _internal_set_itemid(value);
  // @@protoc_insertion_point(field_set:Protocol.S_AddItem.itemId)
}

// int32 slot = 2;
inline void S_AddItem::clear_slot() {
  _impl_.slot_ = 0;
}
inline int32_t S_AddItem::_internal_slot() const {
  return _impl_.slot_;
}
inline int32_t S_AddItem::slot() const {
  // @@protoc_insertion_point(field_get:Protocol.S_AddItem.slot)
  return _internal_slot();
}
inline void S_AddItem::_internal_set_slot(int32_t value) {
  
  _impl_.slot_ = value;
}
inline void S_AddItem::set_slot(int32_t value) {
  _internal_set_slot(value);
  // @@protoc_insertion_point(field_set:Protocol.S_AddItem.slot)
}

// int32 count = 3;
inline void S_AddItem::clear_count() {
  _impl_.count_ = 0;
}
inline int32_t S_AddItem::_internal_count() const {
  return _impl_.count_;
}
inline int32_t S_AddItem::count() const {
  // @@protoc_insertion_point(field_get:Protocol.S_AddItem.count)
  return _internal_count();
}
inline void S_AddItem::_internal_set_count(int32_t value) {
  
  _impl_.count_ = value;
}
inline void S_AddItem::set_count(int32_t value) {
  _internal_set_count(value);
  // @@protoc_insertion_point(field_set:Protocol.S_AddItem.count)
}

// -------------------------------------------------------------------

// S_EquipItem

// int32 equipType = 1;
inline void S_EquipItem::clear_equiptype() {
  _impl_.equiptype_ = 0;
}
inline int32_t S_EquipItem::_internal_equiptype() const {
  return _impl_.equiptype_;
}
inline int32_t S_EquipItem::equiptype() const {
  // @@protoc_insertion_point(field_get:Protocol.S_EquipItem.equipType)
  return _internal_equiptype();
}
inline void S_EquipItem::_internal_set_equiptype(int32_t value) {
  
  _impl_.equiptype_ = value;
}
inline void S_EquipItem::set_equiptype(int32_t value) {
  _internal_set_equiptype(value);
  // @@protoc_insertion_point(field_set:Protocol.S_EquipItem.equipType)
}

// int32 storageSlot = 2;
inline void S_EquipItem::clear_storageslot() {
  _impl_.storageslot_ = 0;
}
inline int32_t S_EquipItem::_internal_storageslot() const {
  return _impl_.storageslot_;
}
inline int32_t S_EquipItem::storageslot() const {
  // @@protoc_insertion_point(field_get:Protocol.S_EquipItem.storageSlot)
  return _internal_storageslot();
}
inline void S_EquipItem::_internal_set_storageslot(int32_t value) {
  
  _impl_.storageslot_ = value;
}
inline void S_EquipItem::set_storageslot(int32_t value) {
  _internal_set_storageslot(value);
  // @@protoc_insertion_point(field_set:Protocol.S_EquipItem.storageSlot)
}

// int32 storageItemId = 3;
inline void S_EquipItem::clear_storageitemid() {
  _impl_.storageitemid_ = 0;
}
inline int32_t S_EquipItem::_internal_storageitemid() const {
  return _impl_.storageitemid_;
}
inline int32_t S_EquipItem::storageitemid() const {
  // @@protoc_insertion_point(field_get:Protocol.S_EquipItem.storageItemId)
  return _internal_storageitemid();
}
inline void S_EquipItem::_internal_set_storageitemid(int32_t value) {
  
  _impl_.storageitemid_ = value;
}
inline void S_EquipItem::set_storageitemid(int32_t value) {
  _internal_set_storageitemid(value);
  // @@protoc_insertion_point(field_set:Protocol.S_EquipItem.storageItemId)
}

// int32 storageItemCount = 4;
inline void S_EquipItem::clear_storageitemcount() {
  _impl_.storageitemcount_ = 0;
}
inline int32_t S_EquipItem::_internal_storageitemcount() const {
  return _impl_.storageitemcount_;
}
inline int32_t S_EquipItem::storageitemcount() const {
  // @@protoc_insertion_point(field_get:Protocol.S_EquipItem.storageItemCount)
  return _internal_storageitemcount();
}
inline void S_EquipItem::_internal_set_storageitemcount(int32_t value) {
  
  _impl_.storageitemcount_ = value;
}
inline void S_EquipItem::set_storageitemcount(int32_t value) {
  _internal_set_storageitemcount(value);
  // @@protoc_insertion_point(field_set:Protocol.S_EquipItem.storageItemCount)
}

// int32 equipItemId = 5;
inline void S_EquipItem::clear_equipitemid() {
  _impl_.equipitemid_ = 0;
}
inline int32_t S_EquipItem::_internal_equipitemid() const {
  return _impl_.equipitemid_;
}
inline int32_t S_EquipItem::equipitemid() const {
  // @@protoc_insertion_point(field_get:Protocol.S_EquipItem.equipItemId)
  return _internal_equipitemid();
}
inline void S_EquipItem::_internal_set_equipitemid(int32_t value) {
  
  _impl_.equipitemid_ = value;
}
inline void S_EquipItem::set_equipitemid(int32_t value) {
  _internal_set_equipitemid(value);
  // @@protoc_insertion_point(field_set:Protocol.S_EquipItem.equipItemId)
}

// int32 equipItemCount = 6;
inline void S_EquipItem::clear_equipitemcount() {
  _impl_.equipitemcount_ = 0;
}
inline int32_t S_EquipItem::_internal_equipitemcount() const {
  return _impl_.equipitemcount_;
}
inline int32_t S_EquipItem::equipitemcount() const {
  // @@protoc_insertion_point(field_get:Protocol.S_EquipItem.equipItemCount)
  return _internal_equipitemcount();
}
inline void S_EquipItem::_internal_set_equipitemcount(int32_t value) {
  
  _impl_.equipitemcount_ = value;
}
inline void S_EquipItem::set_equipitemcount(int32_t value) {
  _internal_set_equipitemcount(value);
  // @@protoc_insertion_point(field_set:Protocol.S_EquipItem.equipItemCount)
}

// int32 attack = 7;
inline void S_EquipItem::clear_attack() {
  _impl_.attack_ = 0;
}
inline int32_t S_EquipItem::_internal_attack() const {
  return _impl_.attack_;
}
inline int32_t S_EquipItem::attack() const {
  // @@protoc_insertion_point(field_get:Protocol.S_EquipItem.attack)
  return _internal_attack();
}
inline void S_EquipItem::_internal_set_attack(int32_t value) {
  
  _impl_.attack_ = value;
}
inline void S_EquipItem::set_attack(int32_t value) {
  _internal_set_attack(value);
  // @@protoc_insertion_point(field_set:Protocol.S_EquipItem.attack)
}

// int32 defence = 8;
inline void S_EquipItem::clear_defence() {
  _impl_.defence_ = 0;
}
inline int32_t S_EquipItem::_internal_defence() const {
  return _impl_.defence_;
}
inline int32_t S_EquipItem::defence() const {
  // @@protoc_insertion_point(field_get:Protocol.S_EquipItem.defence)
  return _internal_defence();
}
inline void S_EquipItem::_internal_set_defence(int32_t value) {
  
  _impl_.defence_ = value;
}
inline void S_EquipItem::set_defence(int32_t value) {
  _internal_set_defence(value);
  // @@protoc_insertion_point(field_set:Protocol.S_EquipItem.defence)
}

// -------------------------------------------------------------------

// S_UnequipItem

// int32 equipType = 1;
inline void S_UnequipItem::clear_equiptype() {
  _impl_.equiptype_ = 0;
}
inline int32_t S_UnequipItem::_internal_equiptype() const {
  return _impl_.equiptype_;
}
inline int32_t S_UnequipItem::equiptype() const {
  // @@protoc_insertion_point(field_get:Protocol.S_UnequipItem.equipType)
  return _internal_equiptype();
}
inline void S_UnequipItem::_internal_set_equiptype(int32_t value) {
  
  _impl_.equiptype_ = value;
}
inline void S_UnequipItem::set_equiptype(int32_t value) {
  _internal_set_equiptype(value);
  // @@protoc_insertion_point(field_set:Protocol.S_UnequipItem.equipType)
}

// int32 storageSlot = 2;
inline void S_UnequipItem::clear_storageslot() {
  _impl_.storageslot_ = 0;
}
inline int32_t S_UnequipItem::_internal_storageslot() const {
  return _impl_.storageslot_;
}
inline int32_t S_UnequipItem::storageslot() const {
  // @@protoc_insertion_point(field_get:Protocol.S_UnequipItem.storageSlot)
  return _internal_storageslot();
}
inline void S_UnequipItem::_internal_set_storageslot(int32_t value) {
  
  _impl_.storageslot_ = value;
}
inline void S_UnequipItem::set_storageslot(int32_t value) {
  _internal_set_storageslot(value);
  // @@protoc_insertion_point(field_set:Protocol.S_UnequipItem.storageSlot)
}

// int32 attack = 3;
inline void S_UnequipItem::clear_attack() {
  _impl_.attack_ = 0;
}
inline int32_t S_UnequipItem::_internal_attack() const {
  return _impl_.attack_;
}
inline int32_t S_UnequipItem::attack() const {
  // @@protoc_insertion_point(field_get:Protocol.S_UnequipItem.attack)
  return _internal_attack();
}
inline void S_UnequipItem::_internal_set_attack(int32_t value) {
  
  _impl_.attack_ = value;
}
inline void S_UnequipItem::set_attack(int32_t value) {
  _internal_set_attack(value);
  // @@protoc_insertion_point(field_set:Protocol.S_UnequipItem.attack)
}

// int32 defence = 4;
inline void S_UnequipItem::clear_defence() {
  _impl_.defence_ = 0;
}
inline int32_t S_UnequipItem::_internal_defence() const {
  return _impl_.defence_;
}
inline int32_t S_UnequipItem::defence() const {
  // @@protoc_insertion_point(field_get:Protocol.S_UnequipItem.defence)
  return _internal_defence();
}
inline void S_UnequipItem::_internal_set_defence(int32_t value) {
  
  _impl_.defence_ = value;
}
inline void S_UnequipItem::set_defence(int32_t value) {
  _internal_set_defence(value);
  // @@protoc_insertion_point(field_set:Protocol.S_UnequipItem.defence)
}

// -------------------------------------------------------------------

// S_UseItem

// int32 equipType = 1;
inline void S_UseItem::clear_equiptype() {
  _impl_.equiptype_ = 0;
}
inline int32_t S_UseItem::_internal_equiptype() const {
  return _impl_.equiptype_;
}
inline int32_t S_UseItem::equiptype() const {
  // @@protoc_insertion_point(field_get:Protocol.S_UseItem.equipType)
  return _internal_equiptype();
}
inline void S_UseItem::_internal_set_equiptype(int32_t value) {
  
  _impl_.equiptype_ = value;
}
inline void S_UseItem::set_equiptype(int32_t value) {
  _internal_set_equiptype(value);
  // @@protoc_insertion_point(field_set:Protocol.S_UseItem.equipType)
}

// int32 remainCount = 2;
inline void S_UseItem::clear_remaincount() {
  _impl_.remaincount_ = 0;
}
inline int32_t S_UseItem::_internal_remaincount() const {
  return _impl_.remaincount_;
}
inline int32_t S_UseItem::remaincount() const {
  // @@protoc_insertion_point(field_get:Protocol.S_UseItem.remainCount)
  return _internal_remaincount();
}
inline void S_UseItem::_internal_set_remaincount(int32_t value) {
  
  _impl_.remaincount_ = value;
}
inline void S_UseItem::set_remaincount(int32_t value) {
  _internal_set_remaincount(value);
  // @@protoc_insertion_point(field_set:Protocol.S_UseItem.remainCount)
}

// int32 newHp = 3;
inline void S_UseItem::clear_newhp() {
  _impl_.newhp_ = 0;
}
inline int32_t S_UseItem::_internal_newhp() const {
  return _impl_.newhp_;
}
inline int32_t S_UseItem::newhp() const {
  // @@protoc_insertion_point(field_get:Protocol.S_UseItem.newHp)
  return _internal_newhp();
}
inline void S_UseItem::_internal_set_newhp(int32_t value) {
  
  _impl_.newhp_ = value;
}
inline void S_UseItem::set_newhp(int32_t value) {
  _internal_set_newhp(value);
  // @@protoc_insertion_point(field_set:Protocol.S_UseItem.newHp)
}

// -------------------------------------------------------------------

// C_EquipItem

// int32 slot = 1;
inline void C_EquipItem::clear_slot() {
  _impl_.slot_ = 0;
}
inline int32_t C_EquipItem::_internal_slot() const {
  return _impl_.slot_;
}
inline int32_t C_EquipItem::slot() const {
  // @@protoc_insertion_point(field_get:Protocol.C_EquipItem.slot)
  return _internal_slot();
}
inline void C_EquipItem::_internal_set_slot(int32_t value) {
  
  _impl_.slot_ = value;
}
inline void C_EquipItem::set_slot(int32_t value) {
  _internal_set_slot(value);
  // @@protoc_insertion_point(field_set:Protocol.C_EquipItem.slot)
}

// -------------------------------------------------------------------

// C_UnequipItem

// int32 equipType = 1;
inline void C_UnequipItem::clear_equiptype() {
  _impl_.equiptype_ = 0;
}
inline int32_t C_UnequipItem::_internal_equiptype() const {
  return _impl_.equiptype_;
}
inline int32_t C_UnequipItem::equiptype() const {
  // @@protoc_insertion_point(field_get:Protocol.C_UnequipItem.equipType)
  return _internal_equiptype();
}
inline void C_UnequipItem::_internal_set_equiptype(int32_t value) {
  
  _impl_.equiptype_ = value;
}
inline void C_UnequipItem::set_equiptype(int32_t value) {
  _internal_set_equiptype(value);
  // @@protoc_insertion_point(field_set:Protocol.C_UnequipItem.equipType)
}

// -------------------------------------------------------------------

// C_UseItem

// int32 slot = 1;
inline void C_UseItem::clear_slot() {
  _impl_.slot_ = 0;
}
inline int32_t C_UseItem::_internal_slot() const {
  return _impl_.slot_;
}
inline int32_t C_UseItem::slot() const {
  // @@protoc_insertion_point(field_get:Protocol.C_UseItem.slot)
  return _internal_slot();
}
inline void C_UseItem::_internal_set_slot(int32_t value) {
  
  _impl_.slot_ = value;
}
inline void C_UseItem::set_slot(int32_t value) {
  _internal_set_slot(value);
  // @@protoc_insertion_point(field_set:Protocol.C_UseItem.slot)
}

// -------------------------------------------------------------------

// C_PartyInvite

// uint64 targetId = 1;
inline void C_PartyInvite::clear_targetid() {
  _impl_.targetid_ = uint64_t{0u};
}
inline uint64_t C_PartyInvite::_internal_targetid() const {
  return _impl_.targetid_;
}
inline uint64_t C_PartyInvite::targetid() const {
  // @@protoc_insertion_point(field_get:Protocol.C_PartyInvite.targetId)
  return _internal_targetid();
}
inline void C_PartyInvite::_internal_set_targetid(uint64_t value) {
  
  _impl_.targetid_ = value;
}
inline void C_PartyInvite::set_targetid(uint64_t value) {
  _internal_set_targetid(value);
  // @@protoc_insertion_point(field_set:Protocol.C_PartyInvite.targetId)
}

// -------------------------------------------------------------------

// C_PartyAnswer

// uint64 inviterId = 1;
inline void C_PartyAnswer::clear_inviterid() {
  _impl_.inviterid_ = uint64_t{0u};
}
inline uint64_t C_PartyAnswer::_internal_inviterid() const {
  return _impl_.inviterid_;
}
inline uint64_t C_PartyAnswer::inviterid() const {
  // @@protoc_insertion_point(field_get:Protocol.C_PartyAnswer.inviterId)
  return _internal_inviterid();
}
inline void C_PartyAnswer::_internal_set_inviterid(uint64_t value) {
  
  _impl_.inviterid_ = value;
}
inline void C_PartyAnswer::set_inviterid(uint64_t value) {
  _internal_set_inviterid(value);
  // @@protoc_insertion_point(field_set:Protocol.C_PartyAnswer.inviterId)
}

// bool accept = 2;
inline void C_PartyAnswer::clear_accept() {
  _impl_.accept_ = false;
}
inline bool C_PartyAnswer::_internal_accept() const {
  return _impl_.accept_;
}
inline bool C_PartyAnswer::accept() const {
  // @@protoc_insertion_point(field_get:Protocol.C_PartyAnswer.accept)
  return _internal_accept();
}
inline void C_PartyAnswer::_internal_set_accept(bool value) {
  
  _impl_.accept_ = value;
}
inline void C_PartyAnswer::set_accept(bool value) {
  _internal_set_accept(value);
  // @@protoc_insertion_point(field_set:Protocol.C_PartyAnswer.accept)
}

// -------------------------------------------------------------------

// C_PartyLeave

// -------------------------------------------------------------------

// S_PartyInvite

// uint64 inviterId = 1;
inline void S_PartyInvite::clear_inviterid() {
  _impl_.inviterid_ = uint64_t{0u};
}
inline uint64_t S_PartyInvite::_internal_inviterid() const {
  return _impl_.inviterid_;
}
inline uint64_t S_PartyInvite::inviterid() const {
  // @@protoc_insertion_point(field_get:Protocol.S_PartyInvite.inviterId)
  return _internal_inviterid();
}
inline void S_PartyInvite::_internal_set_inviterid(uint64_t value) {
  
  _impl_.inviterid_ = value;
}
inline void S_PartyInvite::set_inviterid(uint64_t value) {
  _internal_set_inviterid(value);
  // @@protoc_insertion_point(field_set:Protocol.S_PartyInvite.inviterId)
}

// string inviterName = 2;
inline void S_PartyInvite::clear_invitername() {
  _impl_.invitername_.ClearToEmpty();
}
inline const std::string& S_PartyInvite::invitername() const {
  // @@protoc_insertion_point(field_get:Protocol.S_PartyInvite.inviterName)
  return _internal_invitername();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void S_PartyInvite::set_invitername(ArgT0&& arg0, ArgT... args) {
 
 _impl_.invitername_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Protocol.S_PartyInvite.inviterName)
}
inline std::string* S_PartyInvite::mutable_invitername() {
  std::string* _s = _internal_mutable_invitername();
  // @@protoc_insertion_point(field_mutable:Protocol.S_PartyInvite.inviterName)
  return _s;
}
inline const std::string& S_PartyInvite::_internal_invitername() const {
  return _impl_.invitername_.Get();
}
inline void S_PartyInvite::_internal_set_invitername(const std::string& value) {
  
  _impl_.invitername_.Set(value, GetArenaForAllocation());
}
inline std::string* S_PartyInvite::_internal_mutable_invitername() {
  
  return _impl_.invitername_.Mutable(GetArenaForAllocation());
}
inline std::string* S_PartyInvite::release_invitername() {
  // @@protoc_insertion_point(field_release:Protocol.S_PartyInvite.inviterName)
  return _impl_.invitername_.Release();
}
inline void S_PartyInvite::set_allocated_invitername(std::string* invitername) {
  if (invitername != nullptr) {
    
  } else {
    
  }
  _impl_.invitername_.SetAllocated(invitername, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.invitername_.IsDefault()) {
    _impl_.invitername_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Protocol.S_PartyInvite.inviterName)
}

// -------------------------------------------------------------------

// S_PartyUpdate

// repeated .Protocol.PartyMemberInfo members = 1;
inline int S_PartyUpdate::_internal_members_size() const {
  return _impl_.members_.size();
}
inline int S_PartyUpdate::members_size() const {
  return _internal_members_size();
}
inline ::Protocol::PartyMemberInfo* S_PartyUpdate::mutable_members(int index) {
  // @@protoc_insertion_point(field_mutable:Protocol.S_PartyUpdate.members)
  return _impl_.members_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Protocol::PartyMemberInfo >*
S_PartyUpdate::mutable_members() {
  // @@protoc_insertion_point(field_mutable_list:Protocol.S_PartyUpdate.members)
  return &_impl_.members_;
}
inline const ::Protocol::PartyMemberInfo& S_PartyUpdate::_internal_members(int index) const {
  return _impl_.members_.Get(index);
}
inline const ::Protocol::PartyMemberInfo& S_PartyUpdate::members(int index) const {
  // @@protoc_insertion_point(field_get:Protocol.S_PartyUpdate.members)
  return _internal_members(index);
}
inline ::Protocol::PartyMemberInfo* S_PartyUpdate::_internal_add_members() {
  return _impl_.members_.Add();
}
inline ::Protocol::PartyMemberInfo* S_PartyUpdate::add_members() {
  ::Protocol::PartyMemberInfo* _add = _internal_add_members();
  // @@protoc_insertion_point(field_add:Protocol.S_PartyUpdate.members)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Protocol::PartyMemberInfo >&
S_PartyUpdate::members() const {
  // @@protoc_insertion_point(field_list:Protocol.S_PartyUpdate.members)
  return _impl_.members_;
}

// -------------------------------------------------------------------

// S_PartyLeave

// -------------------------------------------------------------------

// C_Login

// string username = 1;
inline void C_Login::clear_username() {
  _impl_.username_.ClearToEmpty();
}
inline const std::string& C_Login::username() const {
  // @@protoc_insertion_point(field_get:Protocol.C_Login.username)
  return _internal_username();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void C_Login::set_username(ArgT0&& arg0, ArgT... args) {
 
 _impl_.username_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Protocol.C_Login.username)
}
inline std::string* C_Login::mutable_username() {
  std::string* _s = _internal_mutable_username();
  // @@protoc_insertion_point(field_mutable:Protocol.C_Login.username)
  return _s;
}
inline const std::string& C_Login::_internal_username() const {
  return _impl_.username_.Get();
}
inline void C_Login::_internal_set_username(const std::string& value) {
  
  _impl_.username_.Set(value, GetArenaForAllocation());
}
inline std::string* C_Login::_internal_mutable_username() {
  
  return _impl_.username_.Mutable(GetArenaForAllocation());
}
inline std::string* C_Login::release_username() {
  // @@protoc_insertion_point(field_release:Protocol.C_Login.username)
  return _impl_.username_.Release();
}
inline void C_Login::set_allocated_username(std::string* username) {
  if (username != nullptr) {
    
  } else {
    
  }
  _impl_.username_.SetAllocated(username, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.username_.IsDefault()) {
    _impl_.username_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Protocol.C_Login.username)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace Protocol

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_Protocol_2eproto
